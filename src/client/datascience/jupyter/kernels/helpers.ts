/* eslint-disable @typescript-eslint/no-explicit-any */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

import * as path from 'path';
import type { KernelSpec } from '@jupyterlab/services';
import { IJupyterKernelSpec } from '../../types';
import { JupyterKernelSpec } from './jupyterKernelSpec';
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const NamedRegexp = require('named-js-regexp') as typeof import('named-js-regexp');
import type * as nbformat from '@jupyterlab/nbformat';
// eslint-disable-next-line @typescript-eslint/no-require-imports
import cloneDeep = require('lodash/cloneDeep');
import { isCI, PYTHON_LANGUAGE } from '../../../common/constants';
import { IConfigurationService, IPathUtils, Resource } from '../../../common/types';
import { EnvironmentType, PythonEnvironment } from '../../../pythonEnvironments/info';
import {
    IKernel,
    KernelConnectionMetadata,
    LocalKernelSpecConnectionMetadata,
    LiveKernelConnectionMetadata,
    PythonKernelConnectionMetadata
} from './types';
import { PreferredRemoteKernelIdProvider } from '../../notebookStorage/preferredRemoteKernelIdProvider';
import { isPythonNotebook } from '../../notebook/helpers/helpers';
import { DataScience } from '../../../common/utils/localize';
import { Settings, Telemetry } from '../../constants';
import { concatMultilineString } from '../../../../datascience-ui/common';
import { sendTelemetryEvent } from '../../../telemetry';
import { traceError, traceInfo, traceInfoIfCI, traceVerbose } from '../../../common/logger';
import {
    areInterpreterPathsSame,
    getInterpreterHash,
    getNormalizedInterpreterPath
} from '../../../pythonEnvironments/info/interpreter';
import { getTelemetrySafeVersion } from '../../../telemetry/helpers';
import { trackKernelResourceInformation } from '../../telemetry/telemetry';
import { getResourceType } from '../../common';
import { IPythonExecutionFactory } from '../../../common/process/types';
import { SysInfoReason } from '../../interactive-common/interactiveWindowTypes';
import { isDefaultPythonKernelSpecName } from '../../kernel-launcher/localPythonAndRelatedNonPythonKernelSpecFinder';
import { executeSilently } from './kernel';
import { IWorkspaceService } from '../../../common/application/types';
import { getDisplayPath } from '../../../common/platform/fs-paths';
import { removeNotebookSuffixAddedByExtension } from '../jupyterSession';

// Helper functions for dealing with kernels and kernelspecs

// https://jupyter-client.readthedocs.io/en/stable/kernels.html
export const connectionFilePlaceholder = '{connection_file}';

// Find the index of the connection file placeholder in a kernelspec
export function findIndexOfConnectionFile(kernelSpec: Readonly<IJupyterKernelSpec>): number {
    return kernelSpec.argv.findIndex((arg) => arg.includes(connectionFilePlaceholder));
}

type ConnectionWithKernelSpec = LocalKernelSpecConnectionMetadata | PythonKernelConnectionMetadata;
export function kernelConnectionMetadataHasKernelSpec(
    connectionMetadata: KernelConnectionMetadata
): connectionMetadata is ConnectionWithKernelSpec {
    return connectionMetadata.kind !== 'connectToLiveKernel';
}
export function kernelConnectionMetadataHasKernelModel(
    connectionMetadata: KernelConnectionMetadata
): connectionMetadata is LiveKernelConnectionMetadata {
    return connectionMetadata.kind === 'connectToLiveKernel';
}
export function getKernelId(spec: IJupyterKernelSpec, interpreter?: PythonEnvironment) {
    // Non-Python kernels cannot contain an interpreter (even in their id).
    interpreter = isPythonKernelSpec(spec) ? interpreter : undefined;
    // Do not include things like display names, as they aren't unique & can change over time.
    // if the spec name is generated by us, then exclude the leading bit (as it can contain version numbers).
    // & sometimes the kernelspec might not have the version number (if it wasn't available at the time of generation of spec)
    // See getInterpreterKernelSpecName for details of this logic.
    let specName = spec.name;
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    if (isKernelRegisteredByUs(spec) && specName.includes(autoGeneratedKernelNameIdentifier)) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        specName = specName.substring(specName.indexOf(autoGeneratedKernelNameIdentifier));
    }
    // The arguments in the spec can be different for multiple kernel specs pointing to the same interpreter.
    // E.g. we can have pyspark kernels with `"-m", "sparkmagic.kernels.pysparkkernel.pysparkkernel",`
    // & another with "-m","jupyter_nb_ext.kernels.synapse_pyspark.kernel"
    let argsForGenerationOfId = '';
    if (isPythonKernelSpec(spec)) {
        // Ignore the first argument (its the python path).
        // Ignore the common bits such as `-f` & `connection_file`
        argsForGenerationOfId = spec.argv
            .slice(1)
            .filter((item) => !['-f', '{connection_file}'].includes(item))
            .join('#')
            .toLowerCase();
    } else {
        // Lets not assume that non-python kernels cannot have such issues
        argsForGenerationOfId = spec.argv.join('#').toLowerCase();
    }
    return `${spec.id || ''}.${specName}.${getNormalizedInterpreterPath(spec.interpreterPath || spec.path)}.${
        getNormalizedInterpreterPath(interpreter?.path) || ''
    }.${argsForGenerationOfId}`;
}

export function getSysInfoReasonHeader(
    reason: SysInfoReason,
    connection: KernelConnectionMetadata | undefined
): string {
    const displayName = getDisplayNameOrNameOfKernelConnection(connection);
    switch (reason) {
        case SysInfoReason.Start:
        case SysInfoReason.New:
            return DataScience.startedNewKernelHeader().format(displayName);
        case SysInfoReason.Restart:
            return DataScience.restartedKernelHeader().format(displayName);
        case SysInfoReason.Interrupt:
            return DataScience.pythonInterruptFailedHeader();
        case SysInfoReason.Connect:
            return DataScience.connectKernelHeader().format(displayName);
        default:
            traceError('Invalid SysInfoReason');
            return '';
    }
}

export function getDisplayNameOrNameOfKernelConnection(kernelConnection: KernelConnectionMetadata | undefined) {
    const oldDisplayName = getOldFormatDisplayNameOrNameOfKernelConnection(kernelConnection);
    if (!kernelConnection) {
        return oldDisplayName;
    }
    switch (kernelConnection.kind) {
        case 'connectToLiveKernel': {
            return oldDisplayName;
        }
        case 'startUsingRemoteKernelSpec':
        case 'startUsingLocalKernelSpec': {
            if (
                kernelConnection.interpreter?.envType &&
                kernelConnection.interpreter.envType !== EnvironmentType.Global
            ) {
                if (kernelConnection.kernelSpec.language === PYTHON_LANGUAGE) {
                    const pythonVersion = `Python ${
                        getTelemetrySafeVersion(kernelConnection.interpreter.version?.raw || '') || ''
                    }`.trim();
                    return kernelConnection.interpreter.envName
                        ? `${oldDisplayName} (${pythonVersion})`
                        : oldDisplayName;
                } else {
                    // Non-Python kernelspec that launches via python interpreter
                    return kernelConnection.interpreter.envName
                        ? `${oldDisplayName} (${kernelConnection.interpreter.envName})`
                        : oldDisplayName;
                }
            } else {
                return oldDisplayName;
            }
        }
        case 'startUsingPythonInterpreter':
            if (
                kernelConnection.interpreter.envType &&
                kernelConnection.interpreter.envType !== EnvironmentType.Global
            ) {
                const pythonVersion = `Python ${
                    getTelemetrySafeVersion(kernelConnection.interpreter.version?.raw || '') || ''
                }`.trim();
                const pythonDisplayName = pythonVersion.trim();
                return kernelConnection.interpreter.envName
                    ? `${kernelConnection.interpreter.envName} (${pythonDisplayName})`
                    : pythonDisplayName;
            }
    }
    return oldDisplayName;
}
function getOldFormatDisplayNameOrNameOfKernelConnection(kernelConnection: KernelConnectionMetadata | undefined) {
    if (!kernelConnection) {
        return '';
    }
    const displayName =
        kernelConnection.kind === 'connectToLiveKernel'
            ? kernelConnection.kernelModel.display_name
            : kernelConnection.kernelSpec?.display_name;
    const name =
        kernelConnection.kind === 'connectToLiveKernel'
            ? kernelConnection.kernelModel.name
            : kernelConnection.kernelSpec?.name;

    const interpeterName =
        kernelConnection.kind === 'startUsingPythonInterpreter' ? kernelConnection.interpreter.displayName : undefined;

    return displayName || name || interpeterName || '';
}

export function getNameOfKernelConnection(
    kernelConnection: KernelConnectionMetadata | undefined,
    defaultValue: string = ''
) {
    if (!kernelConnection) {
        return defaultValue;
    }
    return kernelConnection.kind === 'connectToLiveKernel'
        ? kernelConnection.kernelModel.name
        : kernelConnection.kernelSpec?.name;
}

export function getKernelPathFromKernelConnection(kernelConnection?: KernelConnectionMetadata): string | undefined {
    if (!kernelConnection) {
        return;
    }
    const model = kernelConnectionMetadataHasKernelModel(kernelConnection) ? kernelConnection.kernelModel : undefined;
    const kernelSpec = kernelConnectionMetadataHasKernelSpec(kernelConnection)
        ? kernelConnection.kernelSpec
        : undefined;
    if (
        kernelConnection.kind === 'startUsingPythonInterpreter' ||
        ((kernelConnection.kind === 'startUsingRemoteKernelSpec' ||
            kernelConnection.kind === 'startUsingLocalKernelSpec') &&
            kernelConnection.kernelSpec.language === PYTHON_LANGUAGE)
    ) {
        return kernelSpec?.metadata?.interpreter?.path || kernelSpec?.interpreterPath || kernelSpec?.path;
    } else {
        // For non python kernels, give preference to the executable path in the kernelspec
        // E.g. if we have a rust kernel, we should show the path to the rust executable not the interpreter (such as conda env that owns the rust runtime).
        return (
            model?.path || kernelSpec?.path || kernelSpec?.metadata?.interpreter?.path || kernelSpec?.interpreterPath
        );
    }
}

export function getRemoteKernelSessionInformation(
    kernelConnection: KernelConnectionMetadata | undefined,
    defaultValue: string = ''
): string {
    if (kernelConnection?.kind === 'connectToLiveKernel') {
        return DataScience.jupyterSelectURIRunningDetailFormat().format(
            kernelConnection.kernelModel.lastActivityTime.toLocaleString(),
            kernelConnection.kernelModel.numberOfConnections.toString()
        );
    }
    return defaultValue;
}

export function getKernelConnectionPath(
    kernelConnection: KernelConnectionMetadata | undefined,
    pathUtils: IPathUtils,
    workspaceService: IWorkspaceService
) {
    if (kernelConnection?.kind === 'connectToLiveKernel') {
        return removeNotebookSuffixAddedByExtension(
            kernelConnection.kernelModel?.notebook?.path || kernelConnection.kernelModel?.model?.path || ''
        );
    }
    const kernelPath = getKernelPathFromKernelConnection(kernelConnection);
    // If we have just one workspace folder opened, then ensure to use relative paths
    // where possible (e.g. for virtual environments).
    const cwd =
        workspaceService.workspaceFolders?.length === 1 ? workspaceService.workspaceFolders[0].uri.fsPath : undefined;
    return kernelPath ? pathUtils.getDisplayName(kernelPath, cwd) : '';
}

export function getInterpreterFromKernelConnectionMetadata(
    kernelConnection?: KernelConnectionMetadata
): Partial<PythonEnvironment> | undefined {
    if (!kernelConnection) {
        return;
    }
    if (kernelConnection.interpreter) {
        return kernelConnection.interpreter;
    }
    const model = kernelConnectionMetadataHasKernelModel(kernelConnection) ? kernelConnection.kernelModel : undefined;
    if (model?.metadata?.interpreter) {
        return model.metadata.interpreter;
    }
    const kernelSpec = kernelConnectionMetadataHasKernelSpec(kernelConnection)
        ? kernelConnection.kernelSpec
        : undefined;
    return kernelSpec?.metadata?.interpreter;
}
export function isPythonKernelConnection(kernelConnection?: KernelConnectionMetadata): boolean {
    if (!kernelConnection) {
        return false;
    }
    if (kernelConnection.kind === 'startUsingPythonInterpreter') {
        return true;
    }
    const model = kernelConnectionMetadataHasKernelModel(kernelConnection) ? kernelConnection.kernelModel : undefined;
    const kernelSpec = kernelConnectionMetadataHasKernelSpec(kernelConnection)
        ? kernelConnection.kernelSpec
        : undefined;
    return model?.language === PYTHON_LANGUAGE || isPythonKernelSpec(kernelSpec);
}
function isPythonKernelSpec(kernelSpec?: IJupyterKernelSpec): boolean {
    const language = (kernelSpec?.language || '').toLowerCase();
    return language === PYTHON_LANGUAGE;
}
export function getKernelConnectionLanguage(kernelConnection?: KernelConnectionMetadata): string | undefined {
    if (!kernelConnection) {
        return;
    }
    // Language is python when starting with Python Interpreter
    if (kernelConnection.kind === 'startUsingPythonInterpreter') {
        return PYTHON_LANGUAGE;
    }

    const model = kernelConnectionMetadataHasKernelModel(kernelConnection) ? kernelConnection.kernelModel : undefined;
    const kernelSpec = kernelConnectionMetadataHasKernelSpec(kernelConnection)
        ? kernelConnection.kernelSpec
        : undefined;
    return model?.language || getLanguageInKernelSpec(kernelSpec);
}
export function getLanguageInNotebookMetadata(metadata?: nbformat.INotebookMetadata): string | undefined {
    if (!metadata) {
        return;
    }
    // If kernel spec is defined & we have a language in that, then use that information.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const kernelSpec: IJupyterKernelSpec | undefined = metadata.kernelspec as any;
    return getLanguageInKernelSpec(kernelSpec) || metadata.language_info?.name;
}
export function getLanguageInKernelSpec(kernelSpec?: IJupyterKernelSpec | undefined): string | undefined {
    // When a kernel spec is stored in ipynb, the `language` of the kernel spec is also saved.
    // Unfortunately there's no strong typing for this.
    return kernelSpec?.language;
}

/**
 * All kernel specs generated/registered/saved & saved by this extension will have this in the name.
 * This helps us easily identify such kernels.
 * WARNING: Never change this, this is stored in ipynb & kernelspec.json.
 */
const autoGeneratedKernelNameIdentifier = 'jvsc74a57bd0';
/**
 * The name generated here is tied to the interpreter & is predictable.
 * WARNING: Changes to this will impact `getKernelId()`
 */
export function getInterpreterKernelSpecName(interpreter?: PythonEnvironment): string {
    // Generate a name from a hash of the interpreter
    // Note it must be prefixed with 'python' and the version number.
    const version = interpreter?.sysVersion ? getTelemetrySafeVersion(interpreter.sysVersion) || '3' : '';
    const versionWithSafeStrings = version.replace(/\./g, '');
    const prefix = interpreter ? `python${versionWithSafeStrings}` : '';
    return interpreter ? `${prefix}${autoGeneratedKernelNameIdentifier}${getInterpreterHash(interpreter)}` : 'python3';
}
/**
 * Whether this is a kernel spec that was generated by the us (Jupyter extension).
 * @returns {('oldVersion' | 'newVersion' | undefined)}
 * `undefined`  - Not generated by us.
 * `oldVersion` - In older versions we used to register kernels with a name that contained a Guid.
 * `newVersion` - In later (current) versions we register kernels with a name that's a combination of  interpreter version + hash of interpreter path.
 */
export function isKernelRegisteredByUs(kernelSpec: IJupyterKernelSpec): 'oldVersion' | 'newVersion' | undefined {
    // Check if this is a kernel we registered in the old days.
    // If it is, then no need to display that (selecting kernels registered is done by selecting the corresponding interpreter).
    // Hence we can hide such kernels.
    // Kernels we create will end with a uuid (with - stripped), & will have interpreter info in the metadata.
    // Only do this for raw kernel scenarios
    if (kernelSpec.name.includes(autoGeneratedKernelNameIdentifier)) {
        return 'newVersion';
    }
    const guidRegEx = /[a-f0-9]{32}$/;
    if (kernelSpec.metadata?.interpreter && kernelSpec.name.toLowerCase().search(guidRegEx) !== -1) {
        return 'oldVersion';
    }
    return;
}

// Create a default kernelspec with the given display name
export function createInterpreterKernelSpec(
    interpreter?: PythonEnvironment,
    rootKernelFilePath?: string
): IJupyterKernelSpec {
    // This creates a kernel spec for an interpreter. When launched, 'python' argument will map to using the interpreter
    // associated with the current resource for launching.
    const defaultSpec: KernelSpec.ISpecModel = {
        name: getInterpreterKernelSpecName(interpreter),
        language: 'python',
        display_name: interpreter?.displayName || 'Python 3',
        metadata: {
            interpreter
        },
        argv: ['python', '-m', 'ipykernel_launcher', '-f', connectionFilePlaceholder],
        env: {},
        resources: {}
    };

    // Generate spec file path if we know where kernel files will go
    const specFile =
        rootKernelFilePath && defaultSpec.name
            ? path.join(rootKernelFilePath, defaultSpec.name, 'kernel.json')
            : undefined;

    return new JupyterKernelSpec(defaultSpec, specFile, interpreter?.path);
}

export function areKernelConnectionsEqual(
    connection1?: KernelConnectionMetadata,
    connection2?: KernelConnectionMetadata
) {
    if (!connection1 && !connection2) {
        return true;
    }
    if (!connection1 && connection2) {
        return false;
    }
    if (connection1 && !connection2) {
        return false;
    }
    return connection1?.id === connection2?.id;
}
// Check if a name is a default python kernel name and pull the version
export function detectDefaultKernelName(name: string) {
    const regEx = NamedRegexp('python\\s*(?<version>(\\d+))', 'g');
    return regEx.exec(name.toLowerCase());
}

export function cleanEnvironment<T>(spec: T): T {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const copy = cloneDeep(spec) as { env?: any };

    if (copy.env) {
        // Scrub the environment of the spec to make sure it has allowed values (they all must be strings)
        // See this issue here: https://github.com/microsoft/vscode-python/issues/11749
        const keys = Object.keys(copy.env);
        keys.forEach((k) => {
            if (copy.env) {
                const value = copy.env[k];
                if (value !== null && value !== undefined) {
                    copy.env[k] = value.toString();
                }
            }
        });
    }

    return copy as T;
}

export function isLocalLaunch(configuration: IConfigurationService) {
    const settings = configuration.getSettings(undefined);
    const serverType: string | undefined = settings.jupyterServerType;

    if (!serverType || serverType.toLowerCase() === Settings.JupyterServerLocalLaunch) {
        return true;
    }

    return false;
}

export function getInterpreterHashInMetadata(
    notebookMetadata: nbformat.INotebookMetadata | undefined
): string | undefined {
    // If the user has kernelspec in metadata & the interpreter hash is stored in metadata, then its a perfect match.
    // This is the preferred approach https://github.com/microsoft/vscode-jupyter/issues/5612
    if (
        typeof notebookMetadata === 'object' &&
        'interpreter' in notebookMetadata &&
        (notebookMetadata as any).interpreter &&
        typeof (notebookMetadata as any).interpreter === 'object' &&
        'hash' in (notebookMetadata as any).interpreter
    ) {
        return (notebookMetadata as any).interpreter.hash;
    }
}
export function findPreferredKernel(
    kernels: KernelConnectionMetadata[],
    resource: Resource,
    languages: string[],
    notebookMetadata: nbformat.INotebookMetadata | undefined,
    preferredInterpreter: PythonEnvironment | undefined,
    remoteKernelPreferredProvider: PreferredRemoteKernelIdProvider | undefined
): KernelConnectionMetadata | undefined {
    traceInfo(
        `Find preferred kernel for ${getDisplayPath(resource)} with metadata ${JSON.stringify(
            notebookMetadata || {}
        )} & preferred interpreter ${getDisplayPath(preferredInterpreter?.path)}`
    );
    let index = -1;

    // First try remote
    if (index < 0 && resource && remoteKernelPreferredProvider) {
        const preferredKernelId = remoteKernelPreferredProvider.getPreferredRemoteKernelId(resource);
        if (preferredKernelId) {
            // Find the kernel that matches
            index = kernels.findIndex(
                (k) => k.kind === 'connectToLiveKernel' && k.kernelModel.id === preferredKernelId
            );
        }
    }

    // If this is an interactive window & we don't have metadata, then just return the preferred interpreter.
    if (!notebookMetadata && getResourceType(resource) === 'interactive' && preferredInterpreter) {
        //  Find kernel that matches the preferred interpreter.
        const kernelMatchingPreferredInterpreter = kernels.find(
            (kernel) =>
                kernel.kind === 'startUsingPythonInterpreter' &&
                areInterpreterPathsSame(kernel.interpreter.path, preferredInterpreter.path)
        );
        if (kernelMatchingPreferredInterpreter) {
            return kernelMatchingPreferredInterpreter;
        }
        // Telemetry to see if this happens in the real world, this should not be possible.
        sendTelemetryEvent(Telemetry.FailedToFindKernelSpecInterpreterForInteractive);
    }

    // If still not found, look for a match based on notebook metadata and interpreter
    if (index < 0) {
        const hasLanguageInfo = notebookMetadata?.language_info?.name ? true : false;
        let nbMetadataLanguage: string | undefined;
        // Interactive window always defaults to Python kernels.
        if (getResourceType(resource) === 'interactive') {
            nbMetadataLanguage = PYTHON_LANGUAGE;
        } else {
            nbMetadataLanguage =
                !notebookMetadata || isPythonNotebook(notebookMetadata) || !hasLanguageInfo
                    ? PYTHON_LANGUAGE
                    : (
                          ((notebookMetadata?.kernelspec as any)?.language as string) ||
                          notebookMetadata?.language_info?.name
                      )?.toLowerCase();
        }
        let bestScore = -1;

        // Find index of the kernelspec that matches the preferred interpreter.
        const preferredInterpreterKernelSpecIndex = preferredInterpreter
            ? kernels.findIndex((spec) => {
                  if (
                      spec.kind === 'startUsingPythonInterpreter' &&
                      spec.kernelSpec &&
                      spec.kernelSpec.language === PYTHON_LANGUAGE &&
                      areInterpreterPathsSame(spec.interpreter.path, preferredInterpreter.path)
                  ) {
                      return true;
                  }
                  return false;
              })
            : -1;

        traceInfoIfCI(`preferredInterpreterKernelSpecIndex = ${preferredInterpreterKernelSpecIndex}`);

        if (
            getResourceType(resource) === 'notebook' &&
            preferredInterpreterKernelSpecIndex >= 0 &&
            !remoteKernelPreferredProvider
        ) {
            // If we don't have any kernelspec, then just return the preferred interpreter for notebooks.
            if (!notebookMetadata?.kernelspec) {
                traceInfoIfCI("Using preferred interpreter as there's no kernelspec in notebook metadata");
                return kernels[preferredInterpreterKernelSpecIndex];
            }

            // // Check if we have any interperter information in the kernelspec.
            // const hasInterpreterInfo =
            //     'interpreter' in notebookMetadata &&
            //     typeof notebookMetadata.interpreter === 'object' &&
            //     notebookMetadata.interpreter !== null;
            // // If we have a kernelspec (with just the name & display name) & no intepreter information
            // // & we cannot find a matching kernel (for the provided name & display name), then just return the preferred interpreter for notebooks.
            // const kernelSpec = notebookMetadata.kernelspec;
            // // eslint-disable-next-line @typescript-eslint/no-explicit-any
            // const definedValuesForKernelSpec = new Set(Object.keys(kernelSpec) as any);
            // definedValuesForKernelSpec.delete('name');
            // definedValuesForKernelSpec.delete('display_name');
            // if (
            //     hasInterpreterInfo &&
            //     definedValuesForKernelSpec.size === 0 &&
            //     !kernels.find((item) => {
            //         if (item.kind === 'startUsingLocalKernelSpec') {
            //             return (
            //                 item.kernelSpec.display_name === kernelSpec.display_name ||
            //                 item.kernelSpec.name === kernelSpec.name
            //             );
            //         } else if (item.kind === 'startUsingPythonInterpreter') {
            //             return (
            //                 item.kernelSpec.display_name === kernelSpec.display_name ||
            //                 item.kernelSpec.name === kernelSpec.name ||
            //                 item.interpreter.displayName === kernelSpec.display_name ||
            //                 item.interpreter.displayName === kernelSpec.name
            //             );
            //         }
            //     })
            // ) {
            //     traceInfoIfCI("Using preferred interpreter as there's no kernelspec in notebook metadata");
            //     return kernels[preferredInterpreterKernelSpecIndex];
            // }
        }

        for (let i = 0; kernels && i < kernels?.length; i = i + 1) {
            const metadata = kernels[i];
            const spec = metadata.kind !== 'connectToLiveKernel' ? metadata.kernelSpec : undefined;
            const speclanguage = getKernelConnectionLanguage(metadata);
            let score = -1;
            let subScore = 0;

            if (spec) {
                traceInfoIfCI(`Checking kernel Spec ${JSON.stringify(spec)}`);
                traceInfoIfCI(`isPythonKernelSpec(spec) = ${isPythonKernelSpec(spec)}`);
                traceInfoIfCI(`isKernelRegisteredByUs(spec) = ${isKernelRegisteredByUs(spec)}`);

                // Check if the kernel spec name matches the hash of the generated kernel spec name.
                // This approach of storing our generated kernelspec name in metadadata is not longer practiced.
                if (
                    !notebookMetadata && // If we don't have metadata, only then should we compare against the interpreter.
                    isKernelRegisteredByUs(spec) === 'newVersion' &&
                    isPythonKernelSpec(spec) &&
                    preferredInterpreter &&
                    spec.name === getInterpreterKernelSpecName(preferredInterpreter)
                ) {
                    // This is a perfect match.
                    traceInfoIfCI('Increased score by +100 for matching names without notebook metadata');
                    score += 100;
                }

                // If the user has kernelspec in metadata & this is a kernelspec we generated & names match, then use that kernelspec.
                // Reason we are only interested kernelspecs we generate is because user can have kernelspecs named `python`.
                // Such kernelspecs are ambiguous (we have no idea what `python` kernel means, its not necessarily tied to a specific interpreter).
                // This approach of storing our generated kernelspec name in metadadata is not longer practiced.
                if (
                    notebookMetadata?.kernelspec?.name &&
                    isKernelRegisteredByUs(spec) &&
                    notebookMetadata.kernelspec.name === spec.name
                ) {
                    // This is a perfect match.
                    traceInfoIfCI('Increased score by +100 for matching names in notbeook metadata');
                    score += 100;
                }

                // If the user has kernelspec in metadata & the interpreter hash is stored in metadata, then its a perfect match.
                // This is the preferred approach https://github.com/microsoft/vscode-jupyter/issues/5612
                const interpreterHashInMetadata = getInterpreterHashInMetadata(notebookMetadata);
                if (
                    (metadata.kind === 'startUsingLocalKernelSpec' ||
                        metadata.kind === 'startUsingRemoteKernelSpec' ||
                        metadata.kind === 'startUsingPythonInterpreter') &&
                    metadata.interpreter &&
                    getInterpreterHash(metadata.interpreter) === interpreterHashInMetadata
                ) {
                    // This is a perfect match.
                    traceInfoIfCI('Increased score by +100 for matching interpreter in notbeook metadata');
                    score += 100;
                }

                // See if the path matches.
                if (
                    spec &&
                    spec.path &&
                    spec.path.length > 0 &&
                    preferredInterpreter &&
                    areInterpreterPathsSame(spec.path, preferredInterpreter.path) &&
                    nbMetadataLanguage === PYTHON_LANGUAGE
                ) {
                    // Path match. This is worth more if no notebook metadata as that should
                    // match first.
                    traceInfoIfCI(
                        `Increased score by ${notebookMetadata ? 1 : 8} for matching spec.path in notbeook metadata`
                    );
                    score += notebookMetadata ? 1 : 8;
                }

                // See if the display name already matches.
                if (spec.display_name && spec.display_name === notebookMetadata?.kernelspec?.display_name) {
                    traceInfoIfCI('Increased score by +16 for matching display_name with metadata');
                    score += 16;
                }
                // See if the name of the environments match (kernel name == environment name).
                // At this point we dont care about version numbers of the Python environments.
                // E.g. assume user opens notebook with metadata pointing to kernelspec with the name `condaPytoch`,
                // & the user has such an environment (with the same name), then its a match.
                if (
                    metadata.interpreter?.envName &&
                    metadata.interpreter?.envName === notebookMetadata?.kernelspec?.name &&
                    nbMetadataLanguage === PYTHON_LANGUAGE &&
                    !notebookMetadata?.kernelspec?.name.toLowerCase().match(isDefaultPythonKernelSpecName)
                ) {
                    traceInfoIfCI('Increased score by +16 for matching env name');
                    score += 16;
                }

                // See if interpreter should be tried instead.
                if (
                    spec.display_name &&
                    spec.display_name === preferredInterpreter?.displayName &&
                    !notebookMetadata?.kernelspec?.display_name &&
                    nbMetadataLanguage === PYTHON_LANGUAGE
                ) {
                    traceInfoIfCI('Increased score by +16 for matching display_name with interpreter');
                    score += 10;
                }

                // Find a kernel spec that matches the language in the notebook metadata.
                if (score <= 0 && nbMetadataLanguage && speclanguage === (nbMetadataLanguage || '')) {
                    traceVerbose(
                        `findPreferredKernel score for speclanguage=${nbMetadataLanguage}, ${getDisplayNameOrNameOfKernelConnection(
                            metadata
                        )} is ${score}`
                    );
                    traceInfoIfCI('Increased score by +1 for matching language');
                    subScore = 1;
                    score = +1;
                }

                // See if the version is the same
                if (
                    preferredInterpreter &&
                    preferredInterpreter.version &&
                    spec &&
                    spec.name &&
                    nbMetadataLanguage === PYTHON_LANGUAGE &&
                    !isKernelRegisteredByUs(spec)
                ) {
                    // Search for a digit on the end of the name. It should match our major version
                    const match = /\D+(\d+)/.exec(spec.name);
                    if (match && match !== null && match.length > 0) {
                        // See if the version number matches
                        const nameVersion = parseInt(match[1][0], 10);
                        if (nameVersion && nameVersion === preferredInterpreter.version.major) {
                            traceInfoIfCI('Increased score by +4 for matching major version');
                            score += 4;
                        }
                    }
                }

                // Give python 3 environments a higher priority over others.
                // E.g. if we end up just looking at the suppof ot ehe languages, then Python2 & Python3 will both get 1.
                // But Python 3 is definitely preferred over Python 2.
                if (
                    nbMetadataLanguage === PYTHON_LANGUAGE &&
                    (metadata.interpreter?.sysVersion?.startsWith('3') ||
                        metadata.interpreter?.version?.major === 3 ||
                        metadata.interpreter?.displayName?.toLowerCase().includes('python 3') ||
                        metadata.interpreter?.displayName?.toLowerCase().includes('python3') ||
                        metadata.interpreter?.path?.toLowerCase().includes('python3') ||
                        spec.argv[0].toLocaleLowerCase().includes('python3'))
                ) {
                    traceInfoIfCI('Increased score by +1 for matching major version 3');
                    score += 1;
                    subScore += 1;
                    traceVerbose(
                        `findPreferredKernel score for Python3, ${getDisplayNameOrNameOfKernelConnection(
                            metadata
                        )} is ${score}`
                    );

                    // If the versions match exactly, then increase the score by another 1
                    if (
                        typeof notebookMetadata === 'object' &&
                        'interpreter' in notebookMetadata &&
                        (notebookMetadata as any).interpreter &&
                        typeof (notebookMetadata as any).interpreter === 'object' &&
                        metadata.kind === 'startUsingPythonInterpreter'
                    ) {
                        const nbMetadataInterpreter = (notebookMetadata as any).interpreter as Partial<
                            PythonEnvironment
                        >;
                        if (
                            nbMetadataInterpreter.version?.raw &&
                            nbMetadataInterpreter.version?.raw === metadata.interpreter.version?.raw
                        ) {
                            traceInfoIfCI(
                                'Increased score by +3 for matching raw version in notebook metadata interpreter'
                            );
                            score += 3;
                        }
                    } else if (
                        metadata.interpreter?.version?.raw &&
                        metadata.interpreter?.version?.raw === preferredInterpreter?.version?.raw
                    ) {
                        traceInfoIfCI('Increased score by +3 for matching raw version in preferred interpreter');
                        score += 3;
                    }
                }

                // If ther'es no kernelspec in the metadata (e.g. blank notebooks),
                // & its a python notebook (language in the notebook metatadata will be Python),
                // Then give preference to the preferred (active) interpreter.
                if (
                    !notebookMetadata?.kernelspec &&
                    preferredInterpreter &&
                    areInterpreterPathsSame(spec.interpreterPath, preferredInterpreter?.path)
                ) {
                    traceInfoIfCI('Increased score by +10 for matching spec.interpreterPath');
                    score += 10;
                }
            }

            // Trace score for kernel
            traceVerbose(
                `findPreferredKernel score for ${getDisplayNameOrNameOfKernelConnection(metadata)} is ${score}`
            );

            // If we have a score of 5, this can only happen if we match against language and find a Python 3 kernel.
            // In such cases, use our preferred interpreter kernel if we have one.
            // I.e. give preference to the preferred interpreter kernelspec if we dont have any matches.
            if (
                subScore === 5 && // This is a bit flakey. Number isn't consistent. Should probably just make the order of kernelspecs have the preferred one first
                score === 5 &&
                (metadata.kind === 'startUsingPythonInterpreter' ||
                    ((metadata.kind === 'startUsingLocalKernelSpec' ||
                        metadata.kind === 'startUsingRemoteKernelSpec') &&
                        metadata.kernelSpec.language === PYTHON_LANGUAGE)) &&
                preferredInterpreterKernelSpecIndex >= 0 &&
                bestScore <= 2
            ) {
                index = preferredInterpreterKernelSpecIndex;
            } else if (score > bestScore) {
                index = i;
                bestScore = score;
            }
        }
    }

    // If still not found, try languages
    if (index < 0) {
        index = kernels.findIndex((kernelSpecConnection) => {
            if (
                kernelSpecConnection.kind === 'startUsingLocalKernelSpec' ||
                kernelSpecConnection.kind === 'startUsingRemoteKernelSpec'
            ) {
                return languages.find((l) => l === kernelSpecConnection.kernelSpec.language);
            } else if (kernelSpecConnection.kind === 'connectToLiveKernel') {
                return languages.find((l) => l === kernelSpecConnection.kernelModel.language);
            } else {
                return false;
            }
        });
    }
    traceInfoIfCI(isCI && index >= 0, `Preferred kernel is ${JSON.stringify(kernels[index])}`);
    return index >= 0 ? kernels[index] : undefined;
}

export async function sendTelemetryForPythonKernelExecutable(
    kernel: IKernel,
    resource: Resource,
    kernelConnection: KernelConnectionMetadata,
    executionService: IPythonExecutionFactory
) {
    if (!kernel.session) {
        return;
    }
    if (!kernelConnection.interpreter || !isPythonKernelConnection(kernelConnection)) {
        return;
    }
    if (
        kernelConnection.kind !== 'startUsingLocalKernelSpec' &&
        kernelConnection.kind !== 'startUsingPythonInterpreter'
    ) {
        return;
    }
    try {
        traceInfoIfCI('Begin sendTelemetryForPythonKernelExecutable');
        const outputs = await executeSilently(kernel.session, 'import sys\nprint(sys.executable)');
        if (outputs.length === 0) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const output: nbformat.IStream = outputs[0] as any;
        if (output.name !== 'stdout' && output.output_type !== 'stream') {
            return;
        }
        const sysExecutable = concatMultilineString(output.text).trim().toLowerCase();
        const match = areInterpreterPathsSame(
            kernelConnection.interpreter.path.toLowerCase(),
            sysExecutable.toLowerCase()
        );
        sendTelemetryEvent(Telemetry.PythonKerneExecutableMatches, undefined, {
            match: match ? 'true' : 'false',
            kernelConnectionType: kernelConnection.kind
        });
        trackKernelResourceInformation(resource, { interpreterMatchesKernel: match });
        if (match) {
            return;
        }

        // Rest of the code can all be async, no need to slow the calling code.

        // The interpreter paths don't match, possible we have a synlink or similar.
        // Lets try to get the path from the interpreter using the exact same code we send to the kernel.
        executionService
            .createActivatedEnvironment({
                interpreter: kernelConnection.interpreter,
                allowEnvironmentFetchExceptions: true,
                bypassCondaExecution: true
            })
            .then(async (execService) => {
                const execOutput = await execService.exec(['-c', 'import sys;print(sys.executable)'], {
                    throwOnStdErr: false
                });
                if (execOutput.stdout.trim().length > 0) {
                    const match = areInterpreterPathsSame(execOutput.stdout.trim().toLowerCase(), sysExecutable);
                    sendTelemetryEvent(Telemetry.PythonKerneExecutableMatches, undefined, {
                        match: match ? 'true' : 'false',
                        kernelConnectionType: kernelConnection.kind
                    });
                    trackKernelResourceInformation(resource, { interpreterMatchesKernel: match });
                    if (!match) {
                        traceError(
                            `Interpreter started by kernel does not match expectation, expected ${getDisplayPath(
                                kernelConnection.interpreter?.path
                            )}, got ${getDisplayPath(sysExecutable)}`
                        );
                    }
                }
            })
            .catch((ex) => traceError('Failed to compare interpreters', ex));
    } catch (ex) {
        traceError('Failed to compare interpreters', ex);
    }
    traceInfoIfCI('End sendTelemetryForPythonKernelExecutable');
}
