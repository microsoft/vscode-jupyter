// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/* eslint-disable @typescript-eslint/no-explicit-any */
import { Telemetry } from './platform/common/constants';
import { CheckboxState, EventName, SliceOperationSource } from './platform/telemetry/constants';
import { DebuggingTelemetry } from './notebooks/debugger/constants';
import { EnvironmentType } from './platform/pythonEnvironments/info';
import { TelemetryErrorProperties } from './platform/errors/types';
import { ExportFormat } from './notebooks/export/types';
import {
    InterruptResult,
    KernelActionSource,
    KernelConnectionMetadata,
    KernelInterpreterDependencyResponse
} from './kernels/types';
// eslint-disable-next-line
import { PreferredKernelExactMatchReason } from './notebooks/controllers/types';
import { ExcludeType, PickType } from './platform/common/utils/misc';
import { SharedPropertyMapping } from './platform/telemetry/index';
import { IExtensionApi } from './standalone/api/api';
import { IExportedKernelService, Kernel } from './api';

export * from './platform/telemetry/index';
export type DurationMeasurement = {
    /**
     * Duration of a measure in milliseconds.
     * Common measurement used across a number of events.
     */
    duration: number;
};
export type ResourceTypeTelemetryProperty = {
    /**
     * Used to determine whether this event is related to a Notebooks or Interactive window.
     * Common to most of the events.
     */
    resourceType?: 'notebook' | 'interactive';
};

type Owner = 'donjayamanne' | 'amunger' | 'IanMatthewHuff' | 'rebornix' | 'roblourens' | 'unknown';
type Feature =
    | 'Notebook'
    | 'InteractiveWindow'
    | 'PlotViewer'
    | 'DataFrameViewer'
    | 'Debugger'
    | 'KernelPicker'
    | 'Import-Export'
    | 'VariableViewer';
type EventTag = 'Cell Execution' | 'Remote' | 'Widgets' | 'KernelStartup' | 'IntelliSense';
type EventSource = 'User Action' | 'N/A';
type IGdprEventData = {
    owner: Owner;
    // We extract the jsdoc comments from IEvenNamePropertyMapping found in in telemetry.ts.
    // comment: string;
    expiration?: string;
    /**
     * We extract the jsdoc comments from IEvenNamePropertyMapping found in in telemetry.ts.
     * If this as well as jsDoc is empty, we'll generate an error. At least one of them must be provided.
     * jsDoc comments have been around for a while, hence will be the default.
     */
    comment?: string;
};
type ICustomEventData = {
    /**
     * General feature area of the event.
     */
    feature: 'N/A' | Feature[];
    /**
     * Useful way to categorize events.
     */
    tags?: EventTag[];
    /**
     * Did the user perform an action that triggered this event, or was it something something else.
     * Useful for others to determine whether this is a user action or not.
     */
    source: EventSource;
};
export type IEventData = IGdprEventData & ICustomEventData;
/**
 * Used to define an individual property (data item) of an Event.
 */
type IBasePropertyData = {
    /**
     * EndUserPseudonymizedInformation is what allows us to identify a particular user across time, although we don't know the actual identity of the user. machineId or instanceId fall in this category.
     * PublicPersonalData and PublicNonPersonalData is information that users provide us with, for example, publisher information on the marketplace.
     * CustomerContent is information the user generated such as urls of repositories or custom snippets.
     * CallstackOrException is for error data like callbacks and exceptions. Everything else is SystemMetaData.
     */
    classification:
        | 'SystemMetaData'
        | 'CallstackOrException'
        | 'CustomerContent'
        | 'PublicNonPersonalData'
        | 'EndUserPseudonymizedInformation';
    /**
     * FeatureInsight or PerformanceAndHealth.
     * We only use BusinessInsight for events generated by surveys.
     */
    purpose: 'PerformanceAndHealth' | 'FeatureInsight' | 'BusinessInsight';
    /**
     * Used to specify a reason for collecting the event. This is meant to be more descriptive than `classification` & `purpose`.
     * (if not specified here, then we need jsDoc comments for the corresponding property).
     * The telemetry generation tool will ensure we have necessary comments.
     */
    comment?: string;
    /**
     * Used if you would like to dictate the max product version this telemetry event should be sent in.
     * This allows external tools to specify which events should be removed from the codebase.
     */
    expiration?: string;
    /**
     * Defaults to none. That's appropriate for pretty much all properties rather than a couple of common properties.
     *
     * @type {string}
     * @memberof IPropertyData
     */
    endpoint?: string;
};

export type IPropertyDataNonMeasurement = IBasePropertyData & {
    /**
     * If numbers to are to be sent, they must be sent as measures.
     */
    isMeasurement?: false;
};
export type IPropertyDataMeasurement = IBasePropertyData & {
    /**
     * Numbers are handled differently in the telemetry system.
     */
    isMeasurement: true;
};

/**
 * This will include all of the properties for an Event.
 * This will also include common properties such as error properties, duration, etc.
 */
type AllEventPropertiesData<T> = {
    [P in keyof Required<T>]: Required<T>[P] extends number ? IPropertyDataMeasurement : IPropertyDataNonMeasurement;
};

/**
 * This will include all of the properties for an Event, excluding the common properties.
 * These are the properties that need to be documented and defined.
 */
type EventPropertiesData<T> = AllEventPropertiesData<T>;

type GdprEventDefinition<P> = P extends never | undefined
    ? IEventData
    : keyof EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>> extends never | undefined
    ? IEventData & {
          measures: EventPropertiesData<PickType<P, number | undefined>> | EventPropertiesData<PickType<P, number>>;
      }
    : keyof (EventPropertiesData<PickType<P, number | undefined>> & EventPropertiesData<PickType<P, number>>) extends
          | never
          | undefined
    ? IEventData & {
          properties: EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>>;
      }
    : IEventData & {
          measures: EventPropertiesData<PickType<P, number | undefined>> | EventPropertiesData<PickType<P, number>>;
          properties: EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>>;
      };

type PropertyMeasureDefinition<P> = P extends never
    ? never
    : keyof EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>> extends never
    ? {
          measures: EventPropertiesData<PickType<P, number | undefined>> | EventPropertiesData<PickType<P, number>>;
      }
    : keyof (EventPropertiesData<PickType<P, number | undefined>> &
          EventPropertiesData<PickType<P, number>>) extends never
    ? {
          properties: EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>>;
      }
    : {
          measures: EventPropertiesData<PickType<P, number | undefined>> | EventPropertiesData<PickType<P, number>>;
          properties: EventPropertiesData<ExcludeType<ExcludeType<P, number>, number | undefined>>;
      };

function globallySharedProperties(): PropertyMeasureDefinition<SharedPropertyMapping>['properties'] {
    return {
        isInsiderExtension: {
            classification: 'SystemMetaData',
            purpose: 'FeatureInsight',
            comment: 'Whether this is the Insider version of the Jupyter extension or not. Common to all events.'
        },
        isPythonExtensionInstalled: {
            classification: 'SystemMetaData',
            purpose: 'FeatureInsight',
            comment: 'Whether Python extension is installed or not. Common to all events.'
        },
        rawKernelSupported: {
            classification: 'SystemMetaData',
            purpose: 'FeatureInsight',
            comment: 'Whether the raw kernel is supported or not. Common to all events.'
        }
    };
}
function commonClassificationForDurationProperties(): PropertyMeasureDefinition<DurationMeasurement>['measures'] {
    return {
        duration: {
            classification: 'PublicNonPersonalData',
            purpose: 'PerformanceAndHealth',
            isMeasurement: true
        }
    };
}
function commonClassificationForResourceType(): PropertyMeasureDefinition<ResourceTypeTelemetryProperty>['properties'] {
    return {
        resourceType: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'FeatureInsight'
        }
    };
}
function commonClassificationForErrorProperties(): PropertyMeasureDefinition<TelemetryErrorProperties>['properties'] {
    return {
        failed: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        failureCategory: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        failureSubCategory: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        pythonErrorFile: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        pythonErrorFolder: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        pythonErrorPackage: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        },
        stackTrace: {
            classification: 'PublicNonPersonalData',
            comment: '',
            purpose: 'PerformanceAndHealth'
        }
    };
}
function commonClassificationForResourceSpecificTelemetryProperties(): PropertyMeasureDefinition<ResourceSpecificTelemetryProperties> {
    return {
        properties: {
            actionSource: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            disableUI: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            userExecutedCell: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            resourceHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            },
            pythonEnvironmentVersion: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            pythonEnvironmentType: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            pythonEnvironmentPath: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            pythonEnvironmentPackages: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            kernelSessionId: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            kernelLanguage: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            kernelSpecHash: {
                classification: 'EndUserPseudonymizedInformation',
                purpose: 'FeatureInsight'
            },
            kernelId: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            kernelConnectionType: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            isUsingActiveInterpreter: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            capturedEnvVars: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            newKernelPicker: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            },
            ...commonClassificationForResourceType()
        }
    };
}

export const CommonProperties = {
    ...commonClassificationForDurationProperties(),
    ...commonClassificationForErrorProperties(),
    // ...commonClassificationForResourceSpecificTelemetryProperties(),
    // ...commonClassificationForResourceType(),
    ...globallySharedProperties()
};
export const CommonPropertyAndMeasureTypeNames = [
    'ResourceSpecificTelemetryProperties',
    'DurationMeasurement',
    'ResourceTypeTelemetryProperty',
    'TelemetryErrorProperties'
];

export type TelemetryEventInfo<P> = GdprEventDefinition<P>;

export type ResourceSpecificTelemetryProperties = ResourceTypeTelemetryProperty &
    Partial<{
        /**
         * Whether the user executed a cell.
         * Common to most of the events.
         */
        userExecutedCell?: boolean;
        /**
         * Hash of the Kernel Connection id.
         * Common to most of the events.
         */
        kernelId: string;
        /**
         * Hash of the kernelspec file (so we do not end up with duplicate telemetry for the same user in same session)
         */
        kernelSpecHash: string;
        /**
         * Whether the notebook startup UI (progress indicator & the like) was displayed to the user or not.
         * If its not displayed, then its considered an auto start (start in the background, like pre-warming kernel)
         * Common to most of the events.
         */
        disableUI?: boolean;
        /**
         * Hash of the resource (notebook.uri or pythonfile.uri associated with this).
         * If we run the same notebook tomorrow, the hash will be the same.
         * Used to check whether a particular notebook fails across time or not.
         * This is also used to map different telemetry events related to this same resource. E.g. we could have an event sent for starting a notebook with this hash,
         * and then later we get yet another event indicating starting a notebook failed. And another event indicating the Python environment used for this notebook is a conda environment or
         * we have some other event indicating some other piece of data for this resource. With the information across multiple resources we can now join the different data points
         * and have a better understanding of what is going on, e.g. why something failed.
         * Common to most of the events.
         */
        resourceHash?: string;
        /**
         * Unique identifier for an instance of a notebook session.
         * If we restart or run this notebook tomorrow, this id will be different.
         * Id could be something as simple as a hash of the current Epoch time.
         * Common to most of the events.
         */
        kernelSessionId: string;
        /**
         * Whether this resource is using the active Python interpreter or not.
         * Common to most of the events.
         */
        isUsingActiveInterpreter?: boolean;
        /**
         * Found plenty of issues when starting kernels with conda, hence useful to capture this info.
         * Common to most of the events.
         */
        pythonEnvironmentType?: EnvironmentType;
        /**
         * A key, so that rest of the information is tied to this. (hash)
         * Common to most of the events.
         */
        pythonEnvironmentPath?: string;
        /**
         * Found plenty of issues when starting Conda Python 3.7, Python 3.7 Python 3.9 (in early days when ipykernel was not up to date)
         * Common to most of the events.
         */
        pythonEnvironmentVersion?: string;
        /**
         * Comma delimited list of hashed packages & their versions.
         * Common to most of the events.
         */
        pythonEnvironmentPackages?: string;
        /**
         * Whether kernel was started using kernel spec, interpreter, etc.
         * Common to most of the events.
         */
        kernelConnectionType?: KernelConnectionMetadata['kind'];
        /**
         * Language of the kernel connection.
         * Common to most of the events.
         */
        kernelLanguage: string;
        /**
         * Whether this was started by Jupyter extension or a 3rd party.
         * Common to most of the events.
         */
        actionSource: KernelActionSource;
        /**
         * Whether we managed to capture the environment variables or not.
         * In the case of conda environments, `false` would be an error condition, as we must have env variables for conda to work.
         * Common to most of the events.
         */
        capturedEnvVars?: boolean;
        /**
         * Whether using the new kernel picker or not.
         * This will be obsolete once we ship the new kernel picker.
         */
        newKernelPicker?: boolean;
    }>;

export class IEventNamePropertyMapping {
    /**
     * Telemetry event sent with perf measures related to activation and loading of extension.
     */
    public [EventName.EXTENSION_LOAD]: TelemetryEventInfo<{
        /**
         * Number of workspace folders opened
         */
        workspaceFolderCount: number;
        /**
         * Time taken to activate the extension.
         */
        totalActivateTime: number;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        measures: {
            totalActivateTime: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            workspaceFolderCount: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            }
        }
    };
    /**
     * Telemetry event sent when substituting Environment variables to calculate value of variables.
     * E.g. user has a a .env file with tokens that need to be replaced with env variables.
     * such as an env file having the variable `${HOME}`.
     * Gives us an idea of whether users have variable references in their .env files or not.
     */
    [EventName.ENVFILE_VARIABLE_SUBSTITUTION]: TelemetryEventInfo<undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Telemetry event sent when an environment file is detected in the workspace.
     */
    [EventName.ENVFILE_WORKSPACE]: TelemetryEventInfo<undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Telemetry event sent with hash of an imported python package.
     * Used to detect the popularity of a package, that would help determine which packages
     * need to be prioritized when resolving issues with intellisense or supporting similar issues related to a (known) specific package.
     */
    [EventName.HASHED_PACKAGE_NAME]: TelemetryEventInfo<
        {
            /**
             * Hash of the package name
             */
            hashedNamev2: string;
            /**
             * Whether the package was detected in an existing file (upon open, upon save, upon close) or when it was being used during execution.
             */
            when: 'onExecution' | 'onOpenCloseOrSave';
        } & ResourceTypeTelemetryProperty
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            hashedNamev2: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            when: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            ...commonClassificationForResourceType()
        }
    };
    /**
     * Total time taken by Python extension to return the active Python environment.
     */
    [Telemetry.ActiveInterpreterListingPerf]: TelemetryEventInfo<{
        /**
         * Whether this is the first time in the session.
         * (fetching kernels first time in the session is slower, later its cached).
         * This is a generic property supported for all telemetry (sent by decorators).
         */
        firstTime?: boolean;
        /**
         * Total time taken to list interpreters.
         */
        duration: number;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            firstTime: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Mime type of a cell output.
     * Used to detect the popularity of a mime type, that would help determine which mime types are most common.
     * E.g. if we see widget mimetype, then we know how many use ipywidgets and the like and helps us prioritize widget issues,
     * or prioritize rendering of widgets when opening an existing notebook or the like.
     */
    [Telemetry.CellOutputMimeType]: TelemetryEventInfo<
        {
            /**
             * Mimetype of the output.
             */
            mimeType: string;
            /**
             * Whether the package was detected in an existing file (upon open, upon save, upon close) or when it was being used during execution.
             */
            when: 'onExecution' | 'onOpenCloseOrSave';
        } & ResourceTypeTelemetryProperty
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            mimeType: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            when: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            ...commonClassificationForResourceType()
        }
    };
    /**
     * Used to capture time taken to get environment variables for a python environment.
     * Also lets us know whether it worked or not.
     */
    [Telemetry.GetActivatedEnvironmentVariables]: TelemetryEventInfo<{
        /**
         * Type of the Python environment.
         */
        envType?: EnvironmentType;
        /**
         * Whether the env variables were fetched successfully or not.
         */
        failed: boolean;
        /**
         * Source where the env variables were fetched from.
         * If `python`, then env variables were fetched from Python extension.
         * If `jupyter`, then env variables were fetched from Jupyter extension.
         */
        source: 'python' | 'jupyter';
        /**
         * Reason for not being able to get the env variables.
         */
        reason?:
            | 'noActivationCommands'
            | 'unknownOS'
            | 'emptyVariables'
            | 'unhandledError'
            | 'emptyFromCondaRun'
            | 'emptyFromPython'
            | 'condaActivationFailed'
            | 'failedToGetActivatedEnvVariablesFromPython'
            | 'failedToGetCustomEnvVariables';
        /**
         * Time taken.
         */
        duration: number;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            envType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            failed: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            reason: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            source: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Telemetry event sent when user opens the data viewer via the variable view.
     */
    [EventName.OPEN_DATAVIEWER_FROM_VARIABLE_WINDOW_REQUEST]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        source: 'User Action',
        feature: ['DataFrameViewer', 'VariableViewer']
    };
    /**
     * Telemetry event sent when user opens the data viewer via the variable view and there is an error in doing so.
     */
    [EventName.OPEN_DATAVIEWER_FROM_VARIABLE_WINDOW_ERROR]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        source: 'N/A',
        feature: ['DataFrameViewer', 'VariableViewer']
    };
    /**
     * Telemetry event sent when user opens the data viewer via the variable view and we successfully open the view.
     */
    [EventName.OPEN_DATAVIEWER_FROM_VARIABLE_WINDOW_SUCCESS]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        source: 'User Action',
        feature: ['DataFrameViewer', 'VariableViewer']
    };
    /**
     * User adds a cell below the current cell for IW.
     */
    [Telemetry.AddCellBelow]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * How long on average we spent parsing code lens. Sent on shutdown.
     * We should be able to deprecate in favor of DocumentWithCodeCells, but we should compare the numbers first.
     **/
    [Telemetry.CodeLensAverageAcquisitionTime]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Info about code lenses, count and average time to parse the document.
     **/
    [Telemetry.DocumentWithCodeCells]: TelemetryEventInfo<{
        /**
         * Average time taken to aquire code lenses for a document without using the cache
         **/
        codeLensUpdateTime: number;
        /**
         * Maximum number of code lenses returned for the document
         **/
        maxCellCount: number;
    }> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: {
            codeLensUpdateTime: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            maxCellCount: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            }
        }
    };
    /**
     * Telemetry event sent when user hits the `continue` button while debugging IW
     */
    [Telemetry.DebugContinue]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Telemetry event sent when user debugs the cell in the IW
     */
    [Telemetry.DebugCurrentCell]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Telemetry event sent when user hits the `step over` button while debugging IW
     */
    [Telemetry.DebugStepOver]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Telemetry event sent when user hits the `stop` button while debugging IW
     */
    [Telemetry.DebugStop]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Telemetry event sent when user debugs the file in the IW
     */
    [Telemetry.DebugFileInteractive]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * How often we wait to fetch remote kernel specs or how long it takes to fetch them.
     */
    [Telemetry.JupyterKernelSpecEnumeration]: TelemetryEventInfo<
        | {
              /**
               * Failure to enumerate kernel specs
               */
              failed: true;
              /**
               * Whether Jupyter session manager was ready before we started.
               */
              sessionManagerReady?: boolean;
              /**
               * Whether Jupyter spec manager was ready before we started.
               */
              specsManagerReady?: boolean;
              /**
               * Reason for the failure
               */
              reason:
                  | 'NoSpecsManager'
                  | 'SpecsDidNotChangeInTime'
                  | 'NoSpecsEventAfterRefresh'
                  | 'SpecManagerIsNotReady'
                  | 'SessionManagerIsNotReady';
          }
        | (DurationMeasurement & {
              /**
               * Whether Jupyter session manager was ready before we started.
               */
              wasSessionManagerReady: boolean;
              /**
               * Whether Jupyter spec manager was ready before we started.
               */
              wasSpecsManagerReady: boolean;
              /**
               * Whether Jupyter session manager was ready after we started.
               */
              sessionManagerReady: boolean;
              /**
               * Whether Jupyter spec manager was ready after we started.
               */
              specsManagerReady: boolean;
          })
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: {
            ...commonClassificationForErrorProperties(),
            failed: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            reason: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                comment: 'Reason for failure to fetch kernel specs'
            },
            sessionManagerReady: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            specsManagerReady: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            wasSessionManagerReady: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            wasSpecsManagerReady: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Information about KernelSpecs
     */
    [Telemetry.KernelSpec]: TelemetryEventInfo<{
        /**
         * Unique Id of this Server
         */
        serverIdHash: string;
        /**
         * Extension that owns (provided) this Jupyter Url
         */
        providerExtensionId: string;
        /**
         * Hash of the kernelspec file (so we do not end up with duplicate telemetry for the same user in same session)
         */
        kernelSpecHash: string;
        /**
         * Has of the origin/base Url.
         */
        baseUrlHash: string;
        /**
         * Hash of the Kernel Connection id.
         */
        kernelId: string;
        /**
         * What kind of kernel spec did we fail to create.
         */
        kernelConnectionType:
            | 'startUsingPythonInterpreter'
            | 'startUsingLocalKernelSpec'
            | 'startUsingRemoteKernelSpec'
            | 'connectToLiveRemoteKernel';
        /**
         * Language of the kernel spec.
         */
        kernelLanguage: string | undefined;
        /**
         * Type of the Python environment.
         */
        envType?: EnvironmentType;
        /**
         * Whether the argv0 is same as the interpreter.
         */
        isArgv0SameAsInterpreter?: boolean;
        /**
         * First argument of the kernelSpec argv (without the full path)
         * Helps determine if we have python/conda executables used for kernelSpecs.
         */
        argv0?: string;
        /**
         * argv of KernelSpec
         * Helps determine if we have ipykernel, ipykernel_launcher, etc and other combinations
         * In the case of paths, all path values are stripped, exe names are not.
         */
        argv?: string;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            kernelSpecHash: {
                classification: 'EndUserPseudonymizedInformation',
                purpose: 'FeatureInsight'
            },
            serverIdHash: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            providerExtensionId: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            baseUrlHash: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            kernelId: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            kernelConnectionType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            kernelLanguage: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            envType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            isArgv0SameAsInterpreter: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            argv0: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            argv: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };

    /**
     * Sent when user enters a Remote Jupyter Url
     */
    [Telemetry.EnterRemoteJupyterUrl]: TelemetryEventInfo<{
        /**
         * Unique Id of this Server
         */
        serverIdHash: string;
        /**
         * Has of the origin/base Url.
         */
        baseUrlHash: string;
        /**
         * Whether user is connecting to the local host.
         */
        isLocalHost: boolean;
        /**
         * Whether this is Jupyter Hub or not.
         */
        isJupyterHub: boolean;
        /**
         * Whether the Url was successfully validated or not.
         */
        failed?: boolean;
        /**
         * Failure reason.
         */
        reason?: 'ConnectionFailure' | 'InsecureHTTP' | 'SelfCert' | 'ExpiredCert' | 'AuthFailure';
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: {
            serverIdHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            baseUrlHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            failed: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            },
            isLocalHost: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            },
            isJupyterHub: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            },
            reason: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Disables using Shift+Enter to run code in IW (this is in response to the prompt recommending users to enable this to use the IW)
     */
    [Telemetry.DisableInteractiveShiftEnter]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Enable using Shift+Enter to run code in IW (this is in response to the prompt recommending users to enable this to use the IW)
     */
    [Telemetry.EnableInteractiveShiftEnter]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Time take for jupyter server to start and be ready to run first user cell.
     * (Note: The property `notebook` only gets sent correctly in Jupyter version 2022.8.0 or later)
     */
    [Telemetry.PerceivedJupyterStartupNotebook]: TelemetryEventInfo<
        DurationMeasurement & ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: commonClassificationForResourceSpecificTelemetryProperties().properties,
        measures: {
            ...commonClassificationForDurationProperties()
        }
    };
    /**
     * User exports a .py file with cells as a Jupyter Notebook.
     */
    [Telemetry.ExportPythonFileInteractive]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export', 'InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * User exports a .py file with cells along with the outputs which that file would generate in the Interactive Windows as a Jupyter Notebook.
     */
    [Telemetry.ExportPythonFileAndOutputInteractive]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export', 'InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * User exports the IW or Notebook to a specific format.
     */
    [Telemetry.ClickedExportNotebookAsQuickPick]: TelemetryEventInfo<{
        /**
         * What format to export to was selected in the quick pick.
         */
        format: ExportFormat;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export', 'InteractiveWindow'],
        source: 'User Action',
        properties: {
            format: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Called on the completion of exporting a Jupyter notebook into a new format
     * This is the result of the operation, so it's not tagged as a user action as that
     * comes from ExportNotebookAsCommand or ExportNotebookAsQuickPick
     */
    [Telemetry.ExportNotebookAs]: TelemetryEventInfo<{
        /**
         * What format was the export performed to.
         */
        format: ExportFormat;
        /**
         * Was the export operation cancelled.
         */
        cancelled?: boolean;
        /**
         * Was the export operation successful.
         */
        successful?: boolean;
        /**
         * Did the user end with opening the file in VS Code.
         */
        opened?: boolean;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export'],
        source: 'N/A',
        properties: {
            format: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            cancelled: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            successful: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            opened: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Called when user imports a Jupyter Notebook into a Python file.
     * Command is `Jupyter: Import Jupyter Notebook`
     * Basically user is exporting some jupyter notebook into a Python file.
     */
    [Telemetry.ImportNotebook]: TelemetryEventInfo<{
        /**
         * The command can be called as a command, in which a file then needs to be selected, or with a file
         * as the context already, in which case the import command doesn't ask for selection.
         */
        scope: 'command' | 'file';
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export'],
        source: 'User Action',
        properties: {
            scope: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Called when user exports a Jupyter Notebook or IW into a Python file, HTML, PDF, etc.
     * Command is `Jupyter: Export to Python Script` or `Jupyter: Export to HTML`
     * Basically user is exporting some jupyter notebook or IW into a Python file or other.
     */
    [Telemetry.ExportNotebookAsCommand]: TelemetryEventInfo<{
        /**
         * What format was the export performed to.
         */
        format: ExportFormat;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export'],
        source: 'User Action',
        properties: {
            format: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * The Export Notebook operation failed.
     */
    [Telemetry.ExportNotebookAsFailed]: TelemetryEventInfo<{
        /**
         * What format was the export performed to.
         */
        format: ExportFormat;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['Import-Export'],
        source: 'N/A',
        properties: {
            format: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Sent to indicate we've failed to connect to a Remote Jupyter Server successfully after requesting a password.
     */
    [Telemetry.GetPasswordFailure]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Sent to indicate we've connected to a Remote Jupyter Server successfully after requesting a password.
     */
    [Telemetry.GetPasswordSuccess]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Sent when checking for passwords for Jupyter Hub
     */
    [Telemetry.CheckPasswordJupyterHub]: TelemetryEventInfo<{
        failed: boolean;
        info:
            | 'passwordNotRequired'
            | 'emptyResponseFromLogin'
            | 'gotResponseFromLogin'
            | 'emptyResponseFromApi'
            | 'gotResponseFromApi'
            | 'failure';
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            failed: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            info: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * User tried to open the data viewer and Pandas package was not installed.
     * Note: Not a failure state, as we prompt for install after this.
     */
    [Telemetry.PandasNotInstalled]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * When opening the data viewer the version of Pandas installed was too old.
     */
    [Telemetry.PandasTooOld]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * When opening the data viewer the version of Pandas installed was ok.
     */
    [Telemetry.PandasOK]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * When opening the data viewer the user was prompted to install / upgrade
     * pandas and choose to cancel the operation.
     */
    [Telemetry.PandasInstallCanceled]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * Sent when we have opened any Jupyter notebook in a VS Code session.
     * Not tagging as a user action as this could be something like auto opening a file
     * from a previous session and not a direct user action.
     */
    [Telemetry.OpenNotebookAll]: TelemetryEventInfo<{
        /**
         * Major Format of the Notebook.
         * Useful in determining the most popular versions of nbformats used by users.
         */
        nbformat: number | undefined;
        /**
         * Minor Format of the Notebook.
         * Useful in determining the most popular versions of nbformats used by users.
         */
        nbformat_minor: number | undefined;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        measures: {
            nbformat: {
                classification: 'PublicNonPersonalData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            },
            nbformat_minor: {
                classification: 'PublicNonPersonalData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * A new instance of the plot viewer was opened.
     */
    [Telemetry.OpenPlotViewer]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['PlotViewer'],
        source: 'User Action'
    };
    /**
     * Command to Run all cells from the active python file in the Interactive Window
     */
    [Telemetry.RunAllCells]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run a Selection or Line in the Interactive Window
     */
    [Telemetry.RunSelectionOrLine]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run the current Cell in the Interactive Window
     */
    [Telemetry.RunCurrentCell]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run all the above cells in the Interactive Window
     */
    [Telemetry.RunAllCellsAbove]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run current cell and all below in the Interactive Window
     */
    [Telemetry.RunCellAndAllBelow]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run current cell in the Interactive Window and advance cursor to the next cell
     */
    [Telemetry.RunCurrentCellAndAdvance]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run the active file in the Interactive Window
     */
    [Telemetry.RunFileInteractive]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'User Action'
    };
    /**
     * Command to Run the active file contents up to the cursor location in the Interactive Window
     */
    [Telemetry.RunToLine]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A'
    };
    /**
     * Command to Run the active file contents from the cursor location in the Interactive Window
     */
    [Telemetry.RunFromLine]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A'
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.InsertCellBelowPosition]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.InsertCellBelow]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.InsertCellAbove]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.DeleteCells]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Selection Command in Interactive Window
     */
    [Telemetry.SelectCell]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Selection Command in Interactive Window
     */
    [Telemetry.SelectCellContents]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Selection Command in Interactive Window
     */
    [Telemetry.ExtendSelectionByCellAbove]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Selection Command in Interactive Window
     */
    [Telemetry.ExtendSelectionByCellBelow]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.MoveCellsUp]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.MoveCellsDown]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.ChangeCellToMarkdown]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Edit Command in Interactive Window
     */
    [Telemetry.ChangeCellToCode]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Navigation Command in Interactive Window
     */
    [Telemetry.GotoNextCellInFile]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Cell Navigation Command in Interactive Window
     */
    [Telemetry.GotoPrevCellInFile]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Run the cell and everything below it in the Interactive Window.
     */
    [Telemetry.RunCurrentCellAndAddBelow]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Sent when users chose not to allow connecting to Jupyter over HTTPS when certificate isn't trusted by a trusted CA.
     */
    [Telemetry.SelfCertsMessageClose]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Sent when users chose to use self-signed certificates when connecting to Jupyter over https.
     * Basically this means users has chosen to connect to Jupyter over HTTPS when certificate isn't trusted by a trusted CA.
     */
    [Telemetry.SelfCertsMessageEnabled]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A'
    };
    /**
     * Sent when user installs Jupyter.
     */
    [Telemetry.UserInstalledJupyter]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup']
    };
    /**
     * Installed the python Pandas package.
     */
    [Telemetry.UserInstalledPandas]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * Sent when user click `cancel` button when prompted to install Jupyter.
     */
    [Telemetry.UserDidNotInstallJupyter]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup']
    };
    /**
     * Prompted to install Pandas and chose not to install
     * Note: This could be just ignoring the UI so not a user action.
     */
    [Telemetry.UserDidNotInstallPandas]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * The kernel picker command to install python was shown.
     */
    [Telemetry.PythonNotInstalled]: TelemetryEventInfo<{
        /**
         * The message was displayed, or indicate that the user dismissed or downloaded the message.
         */
        action:
            | 'displayed' // Message displayed.
            | 'dismissed' // user dismissed the message.
            | 'download' // User chose click the download link.
            | 'reload'; // User chose to reload VS Code.
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['KernelPicker'],
        source: 'User Action',
        properties: {
            action: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * The kernel picker command to install python extension was shown.
     */
    [Telemetry.PythonExtensionNotInstalled]: TelemetryEventInfo<{
        /**
         * The message was displayed, or indicate that the user dismissed or downloaded the message.
         */
        action:
            | 'displayed' // Message displayed.
            | 'dismissed' // user dismissed the message.
            | 'download'; // User chose click the download link.
    }> = {
        owner: 'donjayamanne',
        feature: ['KernelPicker'],
        source: 'User Action',
        properties: {
            action: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Python extension was attempted to be installed via the kernel picker command.
     */
    [Telemetry.PythonExtensionInstalledViaKernelPicker]: TelemetryEventInfo<{
        /**
         * Did the Extension install succeed or fail?
         */
        action:
            | 'success' // Correctly installed and hooked the API
            | 'failed'; // Failed to install correctly
    }> = {
        owner: 'donjayamanne',
        feature: ['KernelPicker'],
        source: 'User Action',
        properties: {
            action: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when user is presented with a dialog to install a python package.
     * Also sent with the user's response to the dialog.
     */
    [Telemetry.PythonModuleInstall]: TelemetryEventInfo<
        {
            /**
             * Name of the python module to be installed.
             */
            moduleName: string;
            /**
             * Whether the module was already (once before) installed into the python environment or
             * whether this already exists (detected via `pip list`)
             */
            isModulePresent?: 'true' | undefined;
            /**
             * Action taken by the user or the extension.
             */
            action:
                | 'cancelled' // User cancelled the installation or closed the notebook or the like.
                | 'displayed' // Install prompt may have been displayed.
                | 'prompted' // Install prompt was displayed.
                | 'installed' // Installation disabled (this is what python extension returns).
                | 'ignored' // Installation disabled (this is what python extension returns).
                | 'disabled' // Installation disabled (this is what python extension returns).
                | 'failed' // Installation disabled (this is what python extension returns).
                | 'install' // User chose install from prompt.
                | 'donotinstall' // User chose not to install from prompt.
                | 'differentKernel' // User chose to select a different kernel.
                | 'error' // Some other error.
                | 'installedInJupyter' // The package was successfully installed in Jupyter whilst failed to install in Python ext.
                | 'failedToInstallInJupyter' // Failed to install the package in Jupyter as well as Python ext.
                | 'dismissed' // User chose to dismiss the prompt.
                | 'moreInfo'; // User requested more information on the module in question
            /**
             * Hash of the resource (notebook.uri or pythonfile.uri associated with this).
             * If we run the same notebook tomorrow, the hash will be the same.
             */
            resourceHash?: string;
            /**
             * Type of the python environment.
             */
            pythonEnvType?: EnvironmentType;
        } & ResourceTypeTelemetryProperty &
            DurationMeasurement
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            action: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            isModulePresent: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            moduleName: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            pythonEnvType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            resourceHash: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            ...commonClassificationForResourceType()
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Information banner displayed to give the user the option to configure shift+enter for the Interactive Window.
     */
    [Telemetry.ShiftEnterBannerShown]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A'
    };
    /**
     * User requested to open the data frame viewer.
     */
    [Telemetry.StartShowDataViewer]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'User Action',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Request was made to show the data viewer with specific data frame info.
     */
    [Telemetry.ShowDataViewer]: TelemetryEventInfo<{
        /**
         * Count of rows in the target data frame.
         */
        rows: number | undefined;
        /**
         * Count of columns in the target data frame.
         */
        columns: number | undefined;
    }> = {
        owner: 'IanMatthewHuff',
        source: 'N/A',
        feature: ['DataFrameViewer'],
        measures: {
            rows: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            },
            columns: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            }
        }
    };
    /**
     * Data viewer loads rows in chunks, this event is sent when the rows have all been loaded
     */
    [Telemetry.ShowDataViewerRowsLoaded]: TelemetryEventInfo<{
        /**
         * Timer to indicate how long it took to load all the rows
         */
        rowsTimer: number | undefined;
    }> = {
        owner: 'IanMatthewHuff',
        source: 'N/A',
        feature: ['DataFrameViewer'],
        measures: {
            rowsTimer: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Failed to show the data viewer via the variable view.
     */
    [Telemetry.FailedShowDataViewer]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer', 'VariableViewer'],
        source: 'N/A'
    };
    /**
     * Sent when the jupyter.refreshDataViewer command is invoked
     */
    [Telemetry.RefreshDataViewer]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'User Action'
    };
    /**
     * Whether we managed to start a remote kernel successfully without a backing file.
     */
    [Telemetry.StartedRemoteJupyterSessionWithBackingFile]: TelemetryEventInfo<{
        /**
         * Failed to start the session without the backing file.
         */
        failedWithoutBackingFile: boolean;
        /**
         * Failed to start the session without the backing file.
         */
        failedWithBackingFile: boolean;
        /**
         * Whether this is a local host connection or remote.
         */
        localHost: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            failedWithoutBackingFile: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            failedWithBackingFile: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            localHost: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Information used to determine the zmq binary support.
     * the alpine, libc, armv version is used by the node module @aminya/node-gyp-build to load the zeromq.js binary.
     */
    [Telemetry.ZMQSupport]: TelemetryEventInfo<{
        /**
         * Failed to support zmq.
         */
        failed: boolean;
        /**
         * Whether we tried a fallback to to the older versions of the binaries.
         */
        fallbackTried?: boolean;
        /**
         * Whether alpine or not.
         */
        alpine?: boolean;
        /**
         * libc implementation, from env variable LIBC
         * If the env var LIBC is empty then fallback to 'musl' for Alpine and 'glibc' for others)
         */
        libc?: string;
        /**
         * arch
         */
        zmqarch?: string;
        /**
         * arm version
         */
        armv?: string;
        /**
         * Linux distro id.
         */
        distro_id: string;
        /**
         * Linux distro version id.
         */
        distro_version_id: string;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            failed: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            fallbackTried: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            alpine: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            zmqarch: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            libc: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            armv: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            distro_id: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            distro_version_id: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Information used to determine the zmq binary support.
     * the alpine, libc, armv version is used by the node module @aminya/node-gyp-build to load the zeromq.js binary.
     */
    [Telemetry.ZMQSupportFailure]: TelemetryEventInfo<{
        /**
         * Failed to support zmq.
         */
        failed: boolean;
        /**
         * Whether we tried a fallback to to the older versions of the binaries.
         */
        fallbackTried?: boolean;
        /**
         * Whether alpine or not.
         */
        alpine?: boolean;
        /**
         * libc implementation, from env variable LIBC
         * If the env var LIBC is empty then fallback to 'musl' for Alpine and 'glibc' for others)
         */
        libc?: string;
        /**
         * arch
         */
        zmqarch?: string;
        /**
         * arm version
         */
        armv?: string;
        /**
         * Linux distro id.
         */
        distro_id: string;
        /**
         * Linux distro version id.
         */
        distro_version_id: string;
        /**
         * Error message when azure build module fails to load.
         */
        errorMessage?: string;
        /**
         * Error message when fallback module fails to load.
         */
        fallbackErrorMessage?: string;
        /**
         * List of binaries found on disc.
         */
        zmqBinaries?: string[];
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            failed: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            fallbackTried: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            alpine: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            zmqarch: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            libc: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            armv: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            distro_id: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            distro_version_id: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            errorMessage: {
                classification: 'CallstackOrException',
                purpose: 'FeatureInsight'
            },
            fallbackErrorMessage: {
                classification: 'CallstackOrException',
                purpose: 'FeatureInsight'
            },
            zmqBinaries: {
                classification: 'CallstackOrException',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * How long did it take for a single variable request to be resolved.
     */
    [Telemetry.VariableExplorerFetchTime]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'IanMatthewHuff',
        feature: ['VariableViewer'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Count how many variables were in a variable request.
     */
    [Telemetry.VariableExplorerVariableCount]: TelemetryEventInfo<{
        /**
         * Count of variables requested
         */
        variableCount: number;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['VariableViewer'],
        source: 'N/A',
        measures: {
            variableCount: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            }
        }
    };
    /**
     * Sent to detect the different languages of kernel specs used.
     */
    [Telemetry.KernelSpecLanguage]: TelemetryEventInfo<{
        /**
         * Language of the kernelSpec.
         */
        language: string | undefined;
        /**
         * Whether this is a local or remote kernel.
         */
        kind: 'local' | 'remote';
        /**
         * Whether shell is used to start the kernel. E.g. `"/bin/sh"` is used in the argv of the kernelSpec.
         * OCaml is one such kernel.
         */
        usesShell?: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: {
            kind: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            language: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            usesShell: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Total time taken to Launch a raw kernel.
     */
    [Telemetry.KernelLauncherPerf]: TelemetryEventInfo<
        (DurationMeasurement & ResourceTypeTelemetryProperty) | TelemetryErrorProperties
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: {
            ...commonClassificationForErrorProperties(),
            ...commonClassificationForResourceType()
        },
        measures: {
            ...commonClassificationForDurationProperties()
        }
    };
    /**
     * We have a Python Kernel spec without fully qualified path of Python env.
     * We have no idea how to start these kernels if the user has more than one Python env.
     *
     * We could also have a non-python kernelspec such as Powershell, but the runtime is Python.
     * E.g. argv in kernelspec.json could be ['python', '-m', 'powershell_kernel']
     * E.g. argv in kernelspec.json could be ['python', '-m', 'sparkmagic.kernels.pysparkkernel.pysparkkernel']
     *
     * Note: Have a look at the property `pythonPathDefined` to determine if the python path is ambiguous or not.
     */
    [Telemetry.AmbiguousGlobalKernelSpec]: TelemetryEventInfo<{
        /**
         * Whether kernel was started using kernel spec, interpreter, etc.
         */
        kernelConnectionType: KernelConnectionMetadata['kind'];
        /**
         * Hash of the kernelspec file (so we do not end up with duplicate telemetry for the same user in same session)
         */
        kernelSpecHash: string;
        /**
         * Whether the fully qualified path to the python executable has been defined or not in the KernleSpec file.
         */
        pythonPathDefined: boolean;
        /**
         * If the python path is defined, then this property will be set to true if we found the python env.
         */
        pythonEnvFound?: 'found' | 'foundViaGetEnvDetails' | 'notTrusted' | 'notFound';
        /**
         * Language of the target notebook or interactive window
         */
        language: string;
        /**
         * First argument of the kernelSpec argv (without the full path)
         * Helps determine if we have python/conda executables used for kernelSpecs.
         */
        argv0?: string;
        /**
         * Whether this is a kernelspec created by us.
         */
        isCreatedByUs: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            kernelConnectionType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            pythonPathDefined: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            pythonEnvFound: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            language: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            kernelSpecHash: {
                classification: 'EndUserPseudonymizedInformation',
                purpose: 'FeatureInsight'
            },
            argv0: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            isCreatedByUs: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent when a user runs the interactive window with a new file
     */
    [Telemetry.NewFileForInteractiveWindow]: TelemetryEventInfo<never | undefined> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A'
    };
    [Telemetry.CreateInteractiveWindow]: TelemetryEventInfo<{
        hasKernel: boolean;
        hasOwner: boolean;
        mode: string;
        restored: boolean;
        windowCount: number;
    }> = {
        owner: 'amunger',
        feature: ['InteractiveWindow'],
        source: 'N/A',
        properties: {
            hasKernel: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                comment: 'If the kernel was known at the time of creation'
            },
            hasOwner: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                comment: 'If the window was created for a text file'
            },
            mode: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                comment: 'Creation mode: multiple, perfile or single'
            },
            restored: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                comment: 'Was the window restored from a previous session'
            }
        },
        measures: {
            windowCount: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                comment: 'Number of active interactive windows the user has open',
                isMeasurement: true
            }
        }
    };
    /**
     * Telemetry event sent with name of a Widget that is used.
     * Helps determine which widgets are used the most, and which are not.
     * Useful in prioritizing which widgets to work on if things fail to work.
     */
    [Telemetry.HashedIPyWidgetNameUsed]: TelemetryEventInfo<{
        /**
         * Hash of the widget module.
         * If the widget is found on a CDN, then the unhashed name is sent in `moduleName`.
         */
        hashedName: string;
        /**
         * Name of the widget module
         * Sent only for cases where `source` is `cdn` or when module is found on cdn.
         * As that is the only time we can safely send the name (if its on public CDN then its public information).
         */
        moduleName?: string;
        /**
         * Name of the widget model that's loaded.
         * Sent only for cases where `source` is `cdn` or when module is found on cdn.
         * As that is the only time we can safely send the name (if its on public CDN then its public information).
         */
        modelName?: string;
        /**
         * Version of the Module used, sent only for cases where `source` is `cdn` or when module is found on cdn.
         */
        moduleVersion?: string;
        /**
         * Where did we find the hashed name (CDN or user environment or remote jupyter).
         */
        source?: 'cdn' | 'local' | 'remote';
        /**
         * Whether we searched CDN or not.
         */
        cdnSearched: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            cdnSearched: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            hashedName: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            source: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            moduleName: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            modelName: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            moduleVersion: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Total time taken to discover all IPyWidgets.
     * This is how long it takes to discover all widgets on disc (from python environment).
     */
    [Telemetry.DiscoverIPyWidgetNamesPerf]: TelemetryEventInfo<
        {
            /**
             * Whether we're looking for widgets on local Jupyter environment (local connections) or remote.
             */
            type: 'local' | 'remote';
        } & DurationMeasurement
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            type: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Something went wrong in looking for a widget.
     */
    [Telemetry.HashedIPyWidgetScriptDiscoveryError]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A'
    };
    /**
     * Telemetry event sent when an ipywidget module loads. Module name is hashed.
     */
    [Telemetry.IPyWidgetLoadSuccess]: TelemetryEventInfo<{
        /**
         * Hash of the module name.
         */
        moduleHash: string;
        /**
         * Version of the module.
         */
        moduleVersion: string;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            moduleHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            moduleVersion: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent when an ipywidget module fails to load. Module name is hashed.
     */
    [Telemetry.IPyWidgetLoadFailure]: TelemetryEventInfo<{
        /**
         * Whether we've detected a connection to the internet or not (to access the CDN).
         */
        isOnline: boolean;
        /**
         * Hash of the widget module.
         */
        moduleHash: string;
        /**
         * Version of the module.
         */
        moduleVersion: string;
        /**
         * Whether we timedout getting the source of the script (fetching script source in extension code).
         */
        timedout: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            timedout: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            isOnline: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            moduleHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            moduleVersion: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent when an ipywidget version that is not supported is used & we have trapped this and warned the user abou it.
     */
    [Telemetry.IPyWidgetWidgetVersionNotSupportedLoadFailure]: TelemetryEventInfo<{
        /**
         * Hash of the widget module.
         */
        moduleHash: string;
        /**
         * Version of the module.
         */
        moduleVersion: string;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            moduleHash: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            moduleVersion: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when we prompt user to use a CDN for IPyWidget scripts.
     * This is always sent when we display a prompt.
     */
    [Telemetry.IPyWidgetPromptToUseCDN]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A'
    };
    /**
     * Telemetry sent when user does something with the prompt displayed to user about using CDN for IPyWidget scripts.
     */
    [Telemetry.IPyWidgetPromptToUseCDNSelection]: TelemetryEventInfo<{
        /**
         * The section made by the user.
         */
        selection: 'ok' | 'cancel' | 'dismissed' | 'doNotShowAgain';
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            selection: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent to indicate the overhead of syncing the kernel with the UI.
     */
    [Telemetry.IPyWidgetOverhead]: TelemetryEventInfo<{
        /**
         * Total time in ms
         */
        totalOverheadInMs: number;
        /**
         * Number of messages
         */
        numberOfMessagesWaitedOn: number;
        /**
         * Average wait timne.
         */
        averageWaitTime: number;
        /**
         * Number of registered hook.
         */
        numberOfRegisteredHooks: number;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        measures: {
            totalOverheadInMs: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            numberOfMessagesWaitedOn: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            averageWaitTime: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            numberOfRegisteredHooks: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            }
        }
    };
    /**
     * Telemetry event sent when the widget render function fails (note, this may not be sufficient to capture all failures).
     */
    [Telemetry.IPyWidgetRenderFailure]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A'
    };
    /**
     * Telemetry event sent when the widget tries to send a kernel message but nothing was listening
     */
    [Telemetry.IPyWidgetUnhandledMessage]: TelemetryEventInfo<{
        /**
         * Type of the protocol message sent by Jupyter kernel.
         */
        msg_type: string;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        tags: ['Widgets'],
        source: 'N/A',
        properties: {
            msg_type: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };

    /**
     * After starting a kernel we send a request to get the kernel info.
     * This tracks the total time taken to get the response back (or wether we timedout).
     * If we timeout and later we find successful comms for this session, then timeout is too low
     * or we need more attempts.
     */
    [Telemetry.RawKernelInfoResponse]: TelemetryEventInfo<
        {
            /**
             * Total number of attempts and sending a request and waiting for response.
             */
            attempts: number;
            /**
             * Whether we timedout while waiting for response for Kernel info request.
             */
            timedout: boolean;
        } & DurationMeasurement &
            ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        tags: ['KernelStartup'],
        measures: {
            ...commonClassificationForDurationProperties(),
            attempts: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            }
        },
        properties: {
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            timedout: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Sent to measure time taken to spawn the raw kernel process.
     */
    [Telemetry.RawKernelProcessLaunch]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        tags: ['KernelStartup'],
        measures: commonClassificationForDurationProperties()
    };

    /**
     * Sent when a user executes a cell.
     */
    [Telemetry.ExecuteCell]: TelemetryEventInfo<ResourceSpecificTelemetryProperties> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'User Action',
        tags: ['Cell Execution'],
        properties: {
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            ...commonClassificationForErrorProperties()
        }
    };

    /**
     * Sent when we resume execution of a cell (e.g. when reloading VS Code while a cell was executing).
     */
    [Telemetry.ResumeCellExecution]: TelemetryEventInfo<ResourceSpecificTelemetryProperties> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'User Action',
        tags: ['Cell Execution'],
        properties: {
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            ...commonClassificationForErrorProperties()
        }
    };
    /**
     * Send when a kernel starts.
     */
    [Telemetry.NotebookStart]: TelemetryEventInfo<
        Partial<ResourceSpecificTelemetryProperties & TelemetryErrorProperties>
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        tags: ['KernelStartup'],
        properties: {
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            ...commonClassificationForErrorProperties()
        }
    };
    /**
     * Triggered when the kernel selection changes (note: This can also happen automatically when a notebook is opened).
     * WARNING: Due to changes in VS Code, this isn't necessarily a user action, hence difficult to tell if the user changed it or it changed automatically.
     */
    [Telemetry.SwitchKernel]: TelemetryEventInfo<ResourceSpecificTelemetryProperties> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: commonClassificationForResourceSpecificTelemetryProperties().properties
    };
    /**
     * Telemetry sent when user interrupts the kernel.
     * Check the `resourceType` to determine whether its a Jupyter Notebook or IW.
     */
    [Telemetry.NotebookInterrupt]: TelemetryEventInfo<
        | /** When interrupt is a success */ ({
              /**
               * The result of the interrupt,
               */
              result: InterruptResult;
          } & DurationMeasurement &
              ResourceSpecificTelemetryProperties) // If successful (interrupted, timeout, restart).
        | /** If there are unhandled exceptions */ (DurationMeasurement &
              ResourceSpecificTelemetryProperties &
              TelemetryErrorProperties)
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'User Action',
        properties: {
            result: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            ...commonClassificationForResourceType(),
            ...commonClassificationForErrorProperties(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        },
        measures: {
            ...commonClassificationForDurationProperties()
        }
    };
    /**
     * Telemetry sent when user Restarts the Kernel.
     * Check the `resourceType` to determine whether its a Jupyter Notebook or IW.
     */
    [Telemetry.NotebookRestart]: TelemetryEventInfo<
        | (ResourceTypeTelemetryProperty & DurationMeasurement)
        | /** If there are unhandled exceptions. */ (ResourceTypeTelemetryProperty & TelemetryErrorProperties)
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'User Action',
        properties: {
            ...commonClassificationForResourceType(),
            ...commonClassificationForErrorProperties(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        },
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Telemetry sent when user Kernel startup fails due to a missing python env.
     */
    [Telemetry.KernelStartFailureDueToMissingEnv]: TelemetryEventInfo<
        ResourceTypeTelemetryProperty &
            TelemetryErrorProperties & {
                envMissingReason: 'Unknown' | 'EmptyEnvDetailsFromPython' | 'FailedToGetEnvDetailsFromPython';
                isEmptyCondaEnv: boolean;
                pythonEnvType: string;
                fileExists: boolean;
            }
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'User Action',
        properties: {
            ...commonClassificationForResourceType(),
            ...commonClassificationForErrorProperties(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            envMissingReason: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            isEmptyCondaEnv: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            pythonEnvType: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            fileExists: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Telemetry event sent when raw kernel startup fails due to missing ipykernel dependency.
     * This is useful to see what the user does with this error message.
     */
    [Telemetry.RawKernelSessionStartNoIpykernel]: TelemetryEventInfo<
        {
            /**
             * Captures the result of the error message, whether user dismissed this or picked a new kernel or the like.
             */
            reason: KernelInterpreterDependencyResponse;
        } & ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            ...commonClassificationForResourceType(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        },
        measures: {
            reason: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * This event is sent when the underlying kernelProcess for a
     * RawJupyterSession exits.
     */
    [Telemetry.RawKernelSessionKernelProcessExited]: TelemetryEventInfo<
        {
            /**
             * The kernel process's exit reason, based on the error
             * object's reason
             */
            exitReason: string | undefined;
            /**
             * The kernel process's exit code.
             */
            exitCode: number;
        } & ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            exitReason: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            ...commonClassificationForResourceType(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        },
        measures: {
            exitCode: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            }
        }
    };

    /**
     * This event is sent when a RawJupyterSession's `shutdownSession` method is called.
     * Used to determine what part of the code that shut down the session, so as to determine when and how the kernel session crashed.
     */
    [Telemetry.RawKernelSessionShutdown]: TelemetryEventInfo<
        {
            /**
             * This indicates whether the session being shutdown is a restart session.
             */
            isRequestToShutdownRestartSession: boolean | undefined;
            /**
             * This is the callstack at the time that the `shutdownSession`
             * method is called, intended for us to be ale to identify who
             * tried to shutdown the session.
             */
            stacktrace: string | undefined;
        } & ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            isRequestToShutdownRestartSession: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            stacktrace: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            ...commonClassificationForResourceType(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        }
    };
    /**
     * This event is sent when a RawSession's `dispose` method is called.
     * Used to determine what part of the code that shut down the session, so as to determine when and how the kernel session crashed.
     */
    [Telemetry.RawKernelSessionDisposed]: TelemetryEventInfo<
        {
            /**
             * This is the callstack at the time that the `dispose` method
             * is called, intended for us to be able to identify who called
             * `dispose` on the RawSession.
             */
            stacktrace: string | undefined;
        } & ResourceSpecificTelemetryProperties
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            stacktrace: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            ...commonClassificationForResourceType(),
            ...commonClassificationForResourceSpecificTelemetryProperties().properties
        }
    };

    /**
     * Fired when a user hovers a variable while debugging the IW.
     */
    [Telemetry.RunByLineVariableHover]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };

    /**
     * Telemetry sent with the total number of different types of kernels in the kernel picker.
     */
    [Telemetry.KernelCount]: TelemetryEventInfo<{
        /**
         * Total number of kernel specs in the kernel list.
         */
        kernelSpecCount: number;
        /**
         * Total number of interpreters in the kernel list.
         */
        kernelInterpreterCount: number;
        /**
         * Total number of live kernels in the kernel list.
         */
        kernelLiveCount: number;
        /**
         * Total number of local kernel specs in the list.
         */
        localKernelSpecCount: number;
        /**
         * Total number of remote kernel specs in the list.
         */
        remoteKernelSpecCount: number;
    }> = {
        owner: 'donjayamanne',
        feature: ['KernelPicker'],
        source: 'N/A',
        measures: {
            kernelSpecCount: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            },
            kernelInterpreterCount: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            },
            kernelLiveCount: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            },
            localKernelSpecCount: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            },
            remoteKernelSpecCount: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth',
                isMeasurement: true
            }
        }
    };

    /**
     * We've failed to translate a Jupyter cell output for serialization into a Notebook cell.
     */
    [Telemetry.VSCNotebookCellTranslationFailed]: TelemetryEventInfo<{
        /**
         * Type of the output received from the Jupyter kernel.
         * This is required to identify output types that we're not mapping correctly.
         */
        outputType: string;
    }> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            outputType: {
                classification: 'PublicNonPersonalData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };

    /**
     * How long it took to return our hover tooltips for a .py file.
     */
    [Telemetry.InteractiveFileTooltipsPerf]: TelemetryEventInfo<
        {
            /**
             * Result is null if user signalled cancellation or if we timed out
             */
            isResultNull: boolean;
        } & DurationMeasurement
    > = {
        owner: 'IanMatthewHuff',
        feature: ['InteractiveWindow'],
        tags: ['IntelliSense'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties(),
        properties: {
            isResultNull: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };

    /**
     * The Variable View webview was loaded.
     */
    [Telemetry.NativeVariableViewLoaded]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'IanMatthewHuff',
        feature: ['VariableViewer'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * The Variable View webview was made visible.
     */
    [Telemetry.NativeVariableViewMadeVisible]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['VariableViewer'],
        source: 'N/A'
    };
    /**
     * The Data Viewer webview was loaded.
     */
    [Telemetry.DataViewerWebviewLoaded]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * The Plot Viewer webview was loaded.
     */
    [Telemetry.PlotViewerWebviewLoaded]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'IanMatthewHuff',
        feature: ['PlotViewer'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * A command that the extension contributes is executed.
     */
    [Telemetry.CommandExecuted]: TelemetryEventInfo<{
        /**
         * Name of the command executed.
         */
        command: string;
    }> = {
        owner: 'amunger',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            command: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent whenever the user toggles the checkbox
     * controlling whether a slice is currently being applied to an
     * n-dimensional variable.
     */
    [Telemetry.DataViewerSliceEnablementStateChanged]: TelemetryEventInfo<{
        /**
         * This property is either 'checked' when the result of toggling
         * the checkbox is for slicing to be enabled, or 'unchecked'
         * when the result of toggling the checkbox is for slicing
         * to be disabled.
         */
        newState: CheckboxState;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'User Action',
        properties: {
            newState: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent when a slice is first applied in a
     * data viewer instance to a sliceable Python variable.
     */
    [Telemetry.DataViewerDataDimensionality]: TelemetryEventInfo<{
        /**
         * This property represents the number of dimensions
         * on the target variable being sliced. This should
         * always be 2 at minimum.
         */
        numberOfDimensions: number;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A',
        measures: {
            numberOfDimensions: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight',
                isMeasurement: true
            }
        }
    };
    /**
     * Telemetry event sent whenever the user applies a valid slice
     * to a sliceable Python variable in the data viewer.
     */
    [Telemetry.DataViewerSliceOperation]: TelemetryEventInfo<{
        /**
         * This property indicates whether the slice operation
         * was triggered using the dropdown or the textbox in
         * the slice control panel. `source` is one of `dropdown`,
         * `textbox`, or `checkbox`.
         */
        source: SliceOperationSource;
    }> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'User Action',
        properties: {
            source: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when user attempts to create a Python env via the kernel picker.
     */
    [Telemetry.CreatePythonEnvironment]: TelemetryEventInfo<
        | /* Creation failed */ {
              /**
               * Failed to detect Jupyter.
               */
              failed: true;
              /**
               * Reason for failure.
               * cancelled - User cancelled the operation (cancellation token cancelled).
               * kernelConnectionNotCreated - Kernel connection not created via the kernel finder.
               */
              reason: 'cancelled' | 'kernelConnectionNotCreated';
              /**
               * Type of the Python environment.
               */
              envType?: EnvironmentType;
          }
        | /* Creation succeeded */ {
              /**
               * Whether the kernel dependencies were installed or not.
               */
              dependenciesInstalled: boolean;
          }
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            failed: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            reason: { classification: 'SystemMetaData', purpose: 'PerformanceAndHealth' },
            dependenciesInstalled: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            envType: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when we recommend installing an extension.
     */
    [Telemetry.RecommendExtension]: TelemetryEventInfo<{
        /**
         * Extension we recommended the user to install.
         */
        extensionId: string;
        /**
         * `displayed` - If prompt was displayed
         * `dismissed` - If prompt was displayed & dismissed by the user
         * `ok` - If prompt was displayed & ok clicked by the user
         * `cancel` - If prompt was displayed & cancel clicked by the user
         * `doNotShowAgain` - If prompt was displayed & doNotShowAgain clicked by the user
         */
        action: 'displayed' | 'dismissed' | 'ok' | 'cancel' | 'doNotShowAgain';
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            extensionId: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            },
            action: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Sent when the user accepts the prompt to install ipykernel 6 automatically.
     */
    [DebuggingTelemetry.clickedOnSetup]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Sent when the user dismisses the prompt to install ipykernel 6 automatically.
     */
    [DebuggingTelemetry.closedModal]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * An event describing whether the environment has ipykernel 6 installed.
     */
    [DebuggingTelemetry.ipykernel6Status]: TelemetryEventInfo<{
        /**
         * Whether ipykernel 6 is installed.
         */
        status: 'installed' | 'notInstalled';
    }> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        properties: {
            status: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        },
        source: 'N/A'
    };
    /**
     * Sent when the user attempts to start run by line.
     */
    [DebuggingTelemetry.clickedRunByLine]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Sent when the run by line session starts successfully.
     */
    [DebuggingTelemetry.successfullyStartedRunByLine]: TelemetryEventInfo<undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'N/A'
    };
    /**
     * Telemetry sent when we have managed to successfully start the Interactive Window debugger using the Jupyter protocol.
     */
    [DebuggingTelemetry.successfullyStartedIWJupyterDebugger]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'N/A'
    };
    /**
     * Sent when the user attempts to start debugging a notebook cell.
     */
    [DebuggingTelemetry.clickedRunAndDebugCell]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'User Action'
    };
    /**
     * Sent when the user successfully starts debugging a notebook cell.
     */
    [DebuggingTelemetry.successfullyStartedRunAndDebugCell]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'N/A'
    };
    /**
     * Sent when a notebook debugging session ends.
     */
    [DebuggingTelemetry.endedSession]: TelemetryEventInfo<{
        /**
         * The reason the session ended.
         */
        reason: 'normally' | 'onKernelDisposed' | 'onAnInterrupt' | 'onARestart' | 'withKeybinding';
    }> = {
        owner: 'roblourens',
        feature: ['Debugger'],
        source: 'N/A',
        properties: {
            reason: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when an extension uses our 3rd party Kernel API.
     */
    [Telemetry.JupyterKernelApiUsage]: TelemetryEventInfo<{
        /**
         * Extension Id that's attempting to use the API.
         */
        extensionId: string;
        /**
         * Name of the API member used.
         */
        pemUsed: keyof IExportedKernelService;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            extensionId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            pemUsed: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when an extension uses our 3rd party Kernel Execution API.
     */
    [Telemetry.NewJupyterKernelApiUsage]: TelemetryEventInfo<{
        /**
         * Extension Id that's attempting to use the API.
         */
        extensionId: string;
        /**
         * Name of the API member used.
         */
        pemUsed: keyof Kernel;
        /**
         * Hash of the Kernel Connection id.
         * Common to most of the events.
         */
        kernelId: string;
        /**
         * Gives us an idea how many cells were executed by user before a 3rd party accessed this kernel.
         */
        executionCount: number;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        measures: {
            executionCount: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            }
        },
        properties: {
            extensionId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            pemUsed: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            kernelId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when an extension uses our 3rd party Kernel Execution API.
     */
    [Telemetry.NewJupyterKernelApiExecution]: TelemetryEventInfo<{
        /**
         * Extension Id that's attempting to use the API.
         */
        extensionId: string;
        /**
         * Hash of the Kernel Connection id.
         * Common to most of the events.
         */
        kernelId: string;
        /**
         * Gives us an idea how many cells were executed by user before a 3rd party accessed this kernel.
         */
        executionCount: number;
        /**
         * Total duraction (ms) for execution of this block of code.
         */
        duration: number;
        /**
         * Whether the execution was cancelled or not.
         */
        cancelled: boolean;
        /**
         * How long after execution was started, was the execution cancelled.
         */
        cancelledAfter: number;
        /**
         * Whether the execution was cancelled before the request was sent to the kernel.
         */
        cancelledBeforeRequestSent: boolean;
        /**
         * Whether the execution was cancelled before it was handled by the kernel.
         */
        cancelledBeforeRequestAcknowledged: boolean;
        /**
         * Mime types in the output.
         */
        mimeTypes: string;
        /**
         * Whether the request ws sent to the kernel.
         */
        requestSent: boolean;
        /**
         * How long did it take to send this request to the kernel.
         */
        requestSentAfter: number;
        /**
         * Whether the kernel acknowledged the request.
         */
        requestAcknowledged: boolean;
        /**
         * How long after execution was started, was the request acknowledged by the kernel.
         */
        requestAcknowledgedAfter: number;
        /**
         * Whether the request was never sent (kernel is dead or the like).
         */
        failed: boolean;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        measures: {
            executionCount: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            },
            cancelledAfter: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            },
            requestAcknowledgedAfter: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            },
            requestSentAfter: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'FeatureInsight'
            },
            ...commonClassificationForDurationProperties()
        },
        properties: {
            extensionId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            kernelId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            cancelled: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            requestAcknowledged: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            requestSent: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            cancelledBeforeRequestAcknowledged: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            cancelledBeforeRequestSent: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            mimeTypes: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            failed: {
                classification: 'PublicNonPersonalData',
                comment: '',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Telemetry sent when an extension uses our 3rd party API.
     */
    [Telemetry.JupyterApiUsage]: TelemetryEventInfo<{
        /**
         * Extension Id that's attempting to use the API.
         */
        clientExtId: string;
        /**
         * Name of the API member used.
         */
        pemUsed: keyof IExtensionApi;
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            clientExtId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            pemUsed: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when an extension attempts to use our 3rd party API.
     */
    [Telemetry.JupyterKernelApiAccess]: TelemetryEventInfo<{
        /**
         * Extension Id that's attempting to use the API.
         */
        extensionId: string;
        /**
         * Whether or not the extension was able to use the API.
         */
        allowed: 'yes' | 'no';
    }> = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            extensionId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            allowed: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry sent when startup hooks for Jupyter Kernels are handled by 3rd party extensions.
     * Note: This only applies to kernels belonging to Jupyter Servers contributed by the same extension.
     */
    [Telemetry.JupyterKernelStartupHook]: TelemetryEventInfo<
        {
            /**
             * Extension Id that's attempting to use the API.
             */
            extensionId: string;
            /**
             * Id of the Jupyter Server Provider.
             */
            providerId: string;
        } & DurationMeasurement
    > = {
        owner: 'donjayamanne',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            extensionId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            },
            providerId: {
                classification: 'PublicNonPersonalData',
                purpose: 'FeatureInsight'
            }
        },
        measures: commonClassificationForDurationProperties()
    };

    /**
     * The Python code that we ran to fetch variables had a failure.
     */
    [Telemetry.PythonVariableFetchingCodeFailure]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['VariableViewer'],
        source: 'N/A'
    };
    /**
     * Error information from the debugger output channel while running initialization code.
     */
    [Telemetry.InteractiveWindowDebugSetupCodeFailure]: TelemetryEventInfo<never | undefined> = {
        owner: 'roblourens',
        feature: ['InteractiveWindow', 'Debugger'],
        source: 'N/A'
    };
    /**
     * Sent when Kernel crashes.
     */
    [Telemetry.KernelCrash]: TelemetryEventInfo<ResourceSpecificTelemetryProperties> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'InteractiveWindow'],
        source: 'N/A',
        properties: {
            ...commonClassificationForResourceSpecificTelemetryProperties().properties,
            ...commonClassificationForResourceType()
        }
    };
    /**
     * Called when a controller that would have been shown is hidden by a filter.
     */
    [Telemetry.JupyterKernelHiddenViaFilter]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        source: 'N/A',
        feature: ['KernelPicker']
    };
    /**
     * Called when the user clicks accept on the kernel filter UI.
     */
    [Telemetry.JupyterKernelFilterUsed]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        source: 'User Action',
        feature: ['KernelPicker']
    };
    /**
     * A automated test has been run
     */
    [Telemetry.RunTest]: TelemetryEventInfo<{
        /**
         * The name of the test.
         */
        testName: string;
        /**
         * Whether the test passed or failed.
         */
        testResult: string;
        /**
         * If the test was an initial run to warmup the product.
         */
        perfWarmup?: 'true';
        /**
         * The git commit that the test was run against.
         */
        commitHash?: string;
        /**
         * Timings for segments of the test.
         */
        timedCheckpoints?: string;
    }> = {
        owner: 'amunger',
        feature: 'N/A',
        source: 'N/A',
        properties: {
            testName: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            testResult: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            perfWarmup: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            commitHash: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            timedCheckpoints: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            }
        }
    };
    /**
     * Send we we complete our preferred kernel match. Matched reason might be 'no match'.
     */
    [Telemetry.PreferredKernelExactMatch]: TelemetryEventInfo<{
        /**
         * How/why the preferred kernel was matched the way it was.
         */
        matchedReason: PreferredKernelExactMatchReason | undefined;
    }> = {
        owner: 'donjayamanne',
        feature: ['KernelPicker'],
        source: 'N/A',
        measures: {
            matchedReason: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Telemetry event sent once we've successfully or unsuccessfully parsed the extension.js file in the widget folder.
     * E.g. if we have a widget named ipyvolume, we attempt to parse the nbextensions/ipyvolume/extension.js file to get some info out of it.
     */
    [Telemetry.IPyWidgetExtensionJsInfo]: TelemetryEventInfo<
        | /** Successfully parsed extension.js*/ {
              /**
               * Hash of the widget folder name.
               */
              widgetFolderNameHash: string;
              /**
               * Total number of entries in the require config.
               */
              requireEntryPointCount: number;
              /**
               * Pattern (code style) used to register require.config enties.
               */
              patternUsedToRegisterRequireConfig: string;
          }
        | /** Failed to parse extension.js. */ {
              /**
               * Hash of the widget folder name.
               */
              widgetFolderNameHash: string;
              /**
               * Failed to parse extension.js.
               */
              failed: true;
              /**
               * Reason for the failure.
               */
              failure: 'couldNotLocateRequireConfigStart' | 'couldNotLocateRequireConfigEnd' | 'noRequireConfigEntries';
              /**
               * Pattern (code style) used to register require.config entries.
               */
              patternUsedToRegisterRequireConfig: string | undefined;
          }
    > = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'Notebook'],
        tags: ['Widgets'],
        source: 'N/A',
        measures: {
            requireEntryPointCount: {
                classification: 'SystemMetaData',
                isMeasurement: true,
                purpose: 'PerformanceAndHealth'
            }
        },
        properties: {
            failed: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            failure: {
                classification: 'CallstackOrException',
                purpose: 'PerformanceAndHealth'
            },
            patternUsedToRegisterRequireConfig: {
                classification: 'SystemMetaData',
                purpose: 'PerformanceAndHealth'
            },
            widgetFolderNameHash: {
                classification: 'SystemMetaData',
                purpose: 'FeatureInsight'
            }
        }
    };
    /**
     * Total time take to copy the nb extensions folder.
     */
    [Telemetry.IPyWidgetNbExtensionCopyTime]: TelemetryEventInfo<DurationMeasurement> = {
        owner: 'donjayamanne',
        feature: ['Notebook', 'Notebook'],
        tags: ['Widgets'],
        source: 'N/A',
        measures: commonClassificationForDurationProperties()
    };
    /**
     * Send when we want to install data viewer dependendies, but don't have an active kernel session.
     * Used by the dataViewerDependencyService.
     */
    [Telemetry.NoActiveKernelSession]: TelemetryEventInfo<never | undefined> = {
        owner: 'donjayamanne',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * When the Data Viewer installer is using a Python interpreter to do the install.
     */
    [Telemetry.DataViewerUsingInterpreter]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
    /**
     * When the Data Viewer installer is using the Kernel to do the install.
     */
    [Telemetry.DataViewerUsingKernel]: TelemetryEventInfo<never | undefined> = {
        owner: 'IanMatthewHuff',
        feature: ['DataFrameViewer'],
        source: 'N/A'
    };
}
